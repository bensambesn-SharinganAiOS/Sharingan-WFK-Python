#!/usr/bin/env python3
"""
Sharingan OS - Kali Exploitation Tools Wrappers
Wrappers Python pour tous les outils d'exploitation Kali Linux
"""

import subprocess
import sys
import os
import json
import re
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime

class MetasploitWrapper:
    """Wrapper Python pour Metasploit Framework"""

    def __init__(self):
        self.msfconsole = "msfconsole"
        self.msfrpcd = "msfrpcd"
        self.msfvenom = "msfvenom"

    def start_console(self, **kwargs) -> Dict[str, Any]:
        """D√©marre la console Metasploit"""
        cmd = [self.msfconsole]

        if kwargs.get("quiet"):
            cmd.append("-q")
        if kwargs.get("no_banner"):
            cmd.extend(["-x", "banner off"])

        # Metasploit console est interactif, on retourne les infos de lancement
        return {
            "success": True,
            "command": " ".join(cmd),
            "message": "Metasploit console started. Use -x option for non-interactive commands.",
            "interactive": True
        }

    def search_exploit(self, query: str, **kwargs) -> Dict[str, Any]:
        """Recherche des exploits dans Metasploit"""
        cmd = [self.msfconsole, "-x", f"search {query}; exit"]

        result = self._run_command(cmd, kwargs.get("timeout", 60))

        if result["success"]:
            result["parsed"] = self._parse_search_results(result["stdout"])

        return result

    def use_exploit(self, exploit_name: str, **kwargs) -> Dict[str, Any]:
        """Utilise un exploit sp√©cifique"""
        commands = [
            f"use {exploit_name}",
            f"show options"
        ]

        if kwargs.get("rhost"):
            commands.append(f"set RHOSTS {kwargs['rhost']}")
        if kwargs.get("rport"):
            commands.append(f"set RPORT {kwargs['rport']}")
        if kwargs.get("lhost"):
            commands.append(f"set LHOST {kwargs['lhost']}")
        if kwargs.get("lport"):
            commands.append(f"set LPORT {kwargs['lport']}")

        commands.append("exit")

        cmd = [self.msfconsole, "-x", "; ".join(commands)]

        return self._run_command(cmd, kwargs.get("timeout", 120))

    def create_payload(self, payload: str, format: str = "exe", **kwargs) -> Dict[str, Any]:
        """Cr√©e un payload avec msfvenom"""
        cmd = [self.msfvenom, "-p", payload, "-f", format]

        if kwargs.get("output_file"):
            cmd.extend(["-o", kwargs["output_file"]])
        if kwargs.get("lhost"):
            cmd.extend(["LHOST=" + kwargs["lhost"]])
        if kwargs.get("lport"):
            cmd.extend(["LPORT=" + str(kwargs["lport"])])
        if kwargs.get("encoder"):
            cmd.extend(["-e", kwargs["encoder"]])
        if kwargs.get("iterations"):
            cmd.extend(["-i", str(kwargs["iterations"])])

        result = self._run_command(cmd, kwargs.get("timeout", 300))

        if result["success"] and not kwargs.get("output_file"):
            result["payload_data"] = result["stdout"]

        return result

    def _parse_search_results(self, output: str) -> List[Dict[str, Any]]:
        """Parse les r√©sultats de recherche Metasploit"""
        results = []

        lines = output.split('\n')
        in_results = False

        for line in lines:
            line = line.strip()

            # D√©tecter le d√©but des r√©sultats
            if "Name" in line and "Disclosure Date" in line:
                in_results = True
                continue

            if in_results and line and not line.startswith("-----"):
                # Ligne de r√©sultat
                parts = line.split()
                if len(parts) >= 4:
                    result = {
                        "name": parts[0],
                        "rank": " ".join(parts[1:-2]) if len(parts) > 4 else parts[1],
                        "disclosure_date": parts[-2],
                        "type": parts[-1]
                    }
                    results.append(result)

        return results

    def _run_command(self, cmd: List[str], timeout: int = 300) -> Dict[str, Any]:
        """Ex√©cute une commande"""
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout
            )

            return {
                "success": result.returncode == 0,
                "returncode": result.returncode,
                "stdout": result.stdout,
                "stderr": result.stderr,
                "command": " ".join(cmd)
            }
        except subprocess.TimeoutExpired:
            return {
                "success": False,
                "error": f"Command timed out after {timeout}s",
                "timeout": True
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }

class SqlmapWrapper:
    """Wrapper Python pour SQLMap"""

    def __init__(self):
        self.command = "sqlmap"

    def scan_url(self, url: str, **kwargs) -> Dict[str, Any]:
        """Scanne une URL pour les vuln√©rabilit√©s SQL injection"""
        cmd = [self.command, "-u", url]

        # Options de scan
        if kwargs.get("database"):
            cmd.append("--dbs")
        if kwargs.get("tables"):
            cmd.extend(["-D", kwargs["tables"], "--tables"])
        if kwargs.get("columns"):
            cmd.extend(["-D", kwargs["columns"], "-T", kwargs.get("table", ""), "--columns"])
        if kwargs.get("dump"):
            cmd.extend(["-D", kwargs["dump"], "-T", kwargs.get("table", ""), "--dump"])
        if kwargs.get("batch"):
            cmd.append("--batch")
        if kwargs.get("risk"):
            cmd.extend(["--risk", str(kwargs["risk"])])
        if kwargs.get("level"):
            cmd.extend(["--level", str(kwargs["level"])])
        if kwargs.get("output_file"):
            cmd.extend(["-o", kwargs["output_file"]])

        result = self._run_command(cmd, kwargs.get("timeout", 600))

        if result["success"]:
            result["parsed"] = self._parse_sqlmap_output(result["stdout"])

        return result

    def scan_request_file(self, request_file: str, **kwargs) -> Dict[str, Any]:
        """Scanne un fichier de requ√™te"""
        cmd = [self.command, "-r", request_file]

        # M√™me options que scan_url
        if kwargs.get("database"):
            cmd.append("--dbs")
        if kwargs.get("tables"):
            cmd.extend(["-D", kwargs["tables"], "--tables"])
        if kwargs.get("batch"):
            cmd.append("--batch")

        result = self._run_command(cmd, kwargs.get("timeout", 600))

        if result["success"]:
            result["parsed"] = self._parse_sqlmap_output(result["stdout"])

        return result

    def _parse_sqlmap_output(self, output: str) -> Dict[str, Any]:
        """Parse la sortie SQLMap"""
        parsed = {
            "vulnerable": False,
            "injection_types": [],
            "databases": [],
            "tables": [],
            "columns": [],
            "dumped_data": []
        }

        lines = output.split('\n')

        for line in lines:
            line = line.strip()

            if "is vulnerable" in line or "vulnerable to" in line:
                parsed["vulnerable"] = True

            if "Parameter:" in line and ("vulnerable" in line or "injectable" in line):
                match = re.search(r'Parameter: ([^(]+)', line)
                if match:
                    parsed["injection_types"].append(match.group(1).strip())

            if line.startswith("[") and "]" in line and "available databases" in line:
                # Liste des bases de donn√©es
                db_match = re.search(r'\[([^]]+)\]', line)
                if db_match:
                    parsed["databases"] = db_match.group(1).split(", ")

            if line.startswith("[") and "]" in line and "tables" in line:
                # Liste des tables
                table_match = re.search(r'\[([^]]+)\]', line)
                if table_match:
                    parsed["tables"] = table_match.group(1).split(", ")

        return parsed

    def _run_command(self, cmd: List[str], timeout: int = 600) -> Dict[str, Any]:
        """Ex√©cute une commande"""
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout
            )

            return {
                "success": result.returncode == 0,
                "returncode": result.returncode,
                "stdout": result.stdout,
                "stderr": result.stderr,
                "command": " ".join(cmd)
            }
        except subprocess.TimeoutExpired:
            return {
                "success": False,
                "error": f"Command timed out after {timeout}s",
                "timeout": True
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }

class SearchsploitWrapper:
    """Wrapper Python pour Searchsploit"""

    def __init__(self):
        self.command = "searchsploit"

    def search(self, query: str, **kwargs) -> Dict[str, Any]:
        """Recherche des exploits"""
        cmd = [self.command, query]

        if kwargs.get("json"):
            cmd.append("--json")
        if kwargs.get("exact"):
            cmd.append("--exact")
        if kwargs.get("case"):
            cmd.append("--case")
        if kwargs.get("colour"):
            cmd.append("--colour")

        result = self._run_command(cmd, kwargs.get("timeout", 30))

        if result["success"]:
            if kwargs.get("json"):
                result["parsed"] = json.loads(result["stdout"])
            else:
                result["parsed"] = self._parse_searchsploit_output(result["stdout"])

        return result

    def view_exploit(self, exploit_id: str, **kwargs) -> Dict[str, Any]:
        """Affiche le contenu d'un exploit"""
        cmd = [self.command, "-x", exploit_id]

        result = self._run_command(cmd, kwargs.get("timeout", 30))

        if result["success"]:
            result["exploit_content"] = result["stdout"]

        return result

    def download_exploit(self, exploit_id: str, output_dir: str = ".", **kwargs) -> Dict[str, Any]:
        """T√©l√©charge un exploit"""
        cmd = [self.command, "-m", exploit_id, "-o", output_dir]

        result = self._run_command(cmd, kwargs.get("timeout", 60))

        return result

    def _parse_searchsploit_output(self, output: str) -> List[Dict[str, Any]]:
        """Parse la sortie Searchsploit"""
        results = []

        lines = output.split('\n')
        in_results = False

        for line in lines:
            line = line.strip()

            # Ignorer les lignes d'en-t√™te
            if "Description" in line and "Path" in line:
                in_results = True
                continue

            if in_results and line and not line.startswith("---") and "|" in line:
                parts = line.split("|")
                if len(parts) >= 3:
                    result = {
                        "path": parts[0].strip(),
                        "description": parts[1].strip(),
                        "type": parts[2].strip() if len(parts) > 2 else ""
                    }
                    results.append(result)

        return results

    def _run_command(self, cmd: List[str], timeout: int = 30) -> Dict[str, Any]:
        """Ex√©cute une commande"""
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout
            )

            return {
                "success": result.returncode == 0,
                "returncode": result.returncode,
                "stdout": result.stdout,
                "stderr": result.stderr,
                "command": " ".join(cmd)
            }
        except subprocess.TimeoutExpired:
            return {
                "success": False,
                "error": f"Command timed out after {timeout}s",
                "timeout": True
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }

# Gestionnaire unifi√© pour les outils d'exploitation
class ExploitationToolsManager:
    """Gestionnaire unifi√© des outils d'exploitation"""

    def __init__(self):
        self.tools = {
            "metasploit": MetasploitWrapper(),
            "sqlmap": SqlmapWrapper(),
            "searchsploit": SearchsploitWrapper()
        }

    def get_tool(self, name: str):
        """R√©cup√®re un outil par nom"""
        return self.tools.get(name)

    def list_tools(self) -> List[str]:
        """Liste tous les outils disponibles"""
        return list(self.tools.keys())

    def search_exploits(self, query: str, tool: str = "searchsploit", **kwargs) -> Dict[str, Any]:
        """Recherche des exploits"""
        if tool == "metasploit":
            return self.tools["metasploit"].search_exploit(query, **kwargs)
        elif tool == "searchsploit":
            return self.tools["searchsploit"].search(query, **kwargs)
        else:
            return {"error": f"Unsupported exploit search tool: {tool}"}

    def scan_sql_injection(self, target: str, **kwargs) -> Dict[str, Any]:
        """Scanne pour les injections SQL"""
        return self.tools["sqlmap"].scan_url(target, **kwargs)

    def create_metasploit_payload(self, payload: str, **kwargs) -> Dict[str, Any]:
        """Cr√©e un payload Metasploit"""
        return self.tools["metasploit"].create_payload(payload, **kwargs)

def get_exploitation_tools_manager():
    """Get exploitation tools manager instance"""
    return ExploitationToolsManager()

def main():
    """Test des wrappers d'exploitation"""
    import argparse

    parser = argparse.ArgumentParser(description="Exploitation Tools Wrappers")
    parser.add_argument("--tool", choices=["metasploit", "sqlmap", "searchsploit"],
                       default="searchsploit", help="Tool to use")
    parser.add_argument("--action", choices=["search", "scan", "create"], default="search",
                       help="Action to perform")
    parser.add_argument("target", help="Target (URL, query, etc.)")
    parser.add_argument("--output", "-o", help="Output file")
    parser.add_argument("--json", action="store_true", help="JSON output")

    args = parser.parse_args()

    manager = ExploitationToolsManager()

    print(f"üí• Running {args.tool} {args.action}...")

    result = {"error": "Unsupported action/tool combination"}

    if args.action == "search":
        result = manager.search_exploits(args.target, args.tool, output_file=args.output)
    elif args.action == "scan" and args.tool == "sqlmap":
        result = manager.scan_sql_injection(args.target, output_file=args.output)
    elif args.action == "create" and args.tool == "metasploit":
        result = manager.create_metasploit_payload(args.target, output_file=args.output)

    if args.json:
        print(json.dumps(result, indent=2, default=str))
    else:
        if result.get("success"):
            print("‚úÖ Exploitation operation completed successfully")
            if "parsed" in result:
                parsed = result["parsed"]
                if isinstance(parsed, list) and parsed:
                    print(f"Found {len(parsed)} results")
                    for item in parsed[:3]:  # Montrer les 3 premiers
                        if "description" in item:
                            print(f"  - {item['description']}")
                        elif "name" in item:
                            print(f"  - {item['name']}")
                elif isinstance(parsed, dict):
                    if "vulnerable" in parsed:
                        print(f"Vulnerable: {parsed['vulnerable']}")
                    if "databases" in parsed and parsed["databases"]:
                        print(f"Databases found: {len(parsed['databases'])}")
        else:
            print(f"‚ùå Exploitation operation failed: {result.get('error', 'Unknown error')}")

if __name__ == "__main__":
    main()
