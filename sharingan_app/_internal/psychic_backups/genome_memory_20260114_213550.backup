{
  "capability_name": "genome_memory",
  "content": "#!/usr/bin/env python3\n\"\"\"\nSharingan Genome Memory - ADN du syst\u00e8me\nM\u00e9moire bas\u00e9e sur l'importance et les mutations, pas sur les conversations.\n\"\"\"\n\nimport json\nimport hashlib\nimport time\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Any\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(\"sharingan.genome\")\n\nclass GenePriority(Enum):\n    CORE_FUNCTION = 100\n    PERFORMANCE = 90\n    SECURITY = 95\n    FEATURE = 70\n    CONVERSATION = 10\n    EXPERIMENTAL = 30\n\nclass GeneCategory(Enum):\n    CORE = \"core\"\n    PERFORMANCE = \"performance\"\n    SECURITY = \"security\"\n    FEATURE = \"feature\"\n    CONVERSATION = \"conversation\"\n    EXPERIMENTAL = \"experimental\"\n    KNOWLEDGE = \"knowledge\"\n\n@dataclass\nclass Gene:\n    key: str\n    data: Dict[str, Any]\n    category: str\n    priority: int\n    created_at: str\n    updated_at: str\n    success_rate: float = 0.0\n    usage_count: int = 0\n    mutations: int = 0\n    tags: List[str] = field(default_factory=list)\n    source: str = \"unknown\"\n\n@dataclass\nclass Mutation:\n    gene_key: str\n    old_value: Any\n    new_value: Any\n    reason: str\n    timestamp: str\n    validated: bool = False\n\nclass GenomeMemory:\n    \"\"\"\n    Syst\u00e8me de m\u00e9moire ADN - apprend et \u00e9volue sans conversations.\n    \n    Principe: Comme l'ADN biologique\n    - only les mutations importantes sont retenues\n    - Priorit\u00e9 aux fonctions core et s\u00e9curit\u00e9\n    - Apprentissage par succ\u00e8s/\u00e9chec\n    \"\"\"\n    \n    def __init__(self, base_dir: Optional[Path] = None):\n        self.base_dir = base_dir or Path(__file__).parent / \"data\"\n        self.base_dir.mkdir(exist_ok=True)\n        \n        self.genome_file = self.base_dir / \"genome_memory.json\"\n        self.mutations_file = self.base_dir / \"genome_mutations.json\"\n        self.instincts_file = self.base_dir / \"genome_instincts.json\"\n        \n        self.genes: Dict[str, Gene] = {}\n        self.mutations: List[Mutation] = []\n        self.instincts: List[Dict] = []\n        \n        self._load_all()\n        \n        self.priority_rules = {\n            GeneCategory.CORE: 100,\n            GeneCategory.SECURITY: 95,\n            GeneCategory.PERFORMANCE: 90,\n            GeneCategory.FEATURE: 70,\n            GeneCategory.KNOWLEDGE: 50,\n            GeneCategory.EXPERIMENTAL: 30,\n            GeneCategory.CONVERSATION: 10,\n        }\n    \n    def _load_all(self) -> None:\n        self._load_genome()\n        self._load_mutations()\n        self._load_instincts()\n    \n    def _load_genome(self) -> None:\n        if self.genome_file.exists():\n            try:\n                with open(self.genome_file, 'r') as f:\n                    data = json.load(f)\n                    for key, gene_data in data.items():\n                        self.genes[key] = Gene(**gene_data)\n                logger.info(f\"Loaded {len(self.genes)} genes from genome\")\n            except Exception as e:\n                logger.warning(f\"Failed to load genome: {e}\")\n        else:\n            logger.info(\"No genome file found, starting fresh\")\n    \n    def _load_mutations(self) -> None:\n        if self.mutations_file.exists():\n            try:\n                with open(self.mutations_file, 'r') as f:\n                    self.mutations = [Mutation(**m) for m in json.load(f)]\n                logger.info(f\"Loaded {len(self.mutations)} mutations\")\n            except:\n                self.mutations = []\n    \n    def _load_instincts(self) -> None:\n        if self.instincts_file.exists():\n            try:\n                with open(self.instincts_file, 'r') as f:\n                    self.instincts = json.load(f)\n            except:\n                self.instincts = []\n    \n    def _save_all(self) -> None:\n        self._save_genome()\n        self._save_mutations()\n        self._save_instincts()\n    \n    def _save_genome(self) -> None:\n        with open(self.genome_file, 'w') as f:\n            json.dump({k: v.__dict__ for k, v in self.genes.items()}, f, indent=2, default=str)\n    \n    def _save_mutations(self) -> None:\n        with open(self.mutations_file, 'w') as f:\n            json.dump([m.__dict__ for m in self.mutations], f, indent=2, default=str)\n    \n    def _save_instincts(self) -> None:\n        with open(self.instincts_file, 'w') as f:\n            json.dump(self.instincts, f, indent=2)\n    \n    def mutate(self, key: str, data: Dict, category: str, \n               source: str = \"system\", tags: Optional[List[str]] = None) -> str:\n        \"\"\"\n        Cr\u00e9e ou met \u00e0 jour un g\u00e8ne (mutation).\n        Si le g\u00e8ne existe d\u00e9j\u00e0, c'est une mutation.\n        \"\"\"\n        priority = self.priority_rules.get(GeneCategory(category), 50)\n        now = datetime.now().isoformat()\n        \n        gene_key = f\"{category}_{key}\"\n        \n        if gene_key in self.genes:\n            old_gene = self.genes[gene_key]\n            mutation = Mutation(\n                gene_key=gene_key,\n                old_value=old_gene.data,\n                new_value=data,\n                reason=f\"Mutation de {category}\",\n                timestamp=now\n            )\n            self.mutations.append(mutation)\n            old_gene.mutations += 1\n        \n        gene = Gene(\n            key=gene_key,\n            data=data,\n            category=category,\n            priority=priority,\n            created_at=now,\n            updated_at=now,\n            usage_count=0,\n            mutations=self.genes.get(gene_key, Gene(\"\", {}, \"\", 0, \"\", \"\")).mutations + 1,\n            tags=tags or [],\n            source=source\n        )\n        \n        self.genes[gene_key] = gene\n        self._save_all()\n        \n        return gene_key\n    \n    def record_success(self, gene_key: str) -> None:\n        \"\"\"Enregistre un succ\u00e8s pour un g\u00e8ne\"\"\"\n        if gene_key in self.genes:\n            gene = self.genes[gene_key]\n            gene.usage_count += 1\n            gene.success_rate = min(1.0, gene.success_rate + 0.05)\n            gene.updated_at = datetime.now().isoformat()\n            self._save_genome()\n    \n    def record_failure(self, gene_key: str) -> None:\n        \"\"\"Enregistre un \u00e9chec pour un g\u00e8ne\"\"\"\n        if gene_key in self.genes:\n            gene = self.genes[gene_key]\n            gene.usage_count += 1\n            gene.success_rate = max(0.0, gene.success_rate - 0.1)\n            gene.updated_at = datetime.now().isoformat()\n            self._save_genome()\n    \n    def get_gene(self, key: str, category: str = \"knowledge\") -> Optional[Gene]:\n        \"\"\"R\u00e9cup\u00e8re un g\u00e8ne\"\"\"\n        gene_key = f\"{category}_{key}\"\n        return self.genes.get(gene_key)\n    \n    def find_genes(self, category: Optional[str] = None, \n                   min_priority: int = 0,\n                   tags: Optional[List[str]] = None) -> List[Gene]:\n        \"\"\"Trouve des g\u00e8nes par crit\u00e8res\"\"\"\n        results = []\n        for gene in self.genes.values():\n            if category and gene.category != category:\n                continue\n            if gene.priority < min_priority:\n                continue\n            if tags and not any(t in gene.tags for t in tags):\n                continue\n            results.append(gene)\n        return sorted(results, key=lambda g: g.priority, reverse=True)\n    \n    def get_best_genes(self, limit: int = 10) -> List[Gene]:\n        \"\"\"R\u00e9cup\u00e8re les meilleurs g\u00e8nes (high priority, high success rate)\"\"\"\n        genes = list(self.genes.values())\n        genes.sort(key=lambda g: (g.priority, g.success_rate), reverse=True)\n        return genes[:limit]\n    \n    def add_instinct(self, pattern: str, response: str, \n                     condition: Optional[str] = None) -> None:\n        \"\"\"Ajoute un instinct - r\u00e9ponse automatique \u00e0 un pattern\"\"\"\n        instinct = {\n            \"pattern\": pattern,\n            \"response\": response,\n            \"condition\": condition,\n            \"trigger_count\": 0,\n            \"success_rate\": 0.5,\n            \"created_at\": datetime.now().isoformat()\n        }\n        self.instincts.append(instinct)\n        self._save_instincts()\n    \n    def match_instinct(self, input_text: str) -> Optional[Dict]:\n        \"\"\"Cherche un instinct qui match l'input\"\"\"\n        input_lower = input_text.lower().strip()\n\n        # Chercher d'abord les correspondances exactes\n        for instinct in self.instincts:\n            pattern_lower = instinct[\"pattern\"].lower().strip()\n            if pattern_lower == input_lower:\n                instinct[\"trigger_count\"] += 1\n                self._save_instincts()\n                return instinct\n\n        # Puis les correspondances partielles\n        for instinct in self.instincts:\n            pattern_lower = instinct[\"pattern\"].lower().strip()\n            if pattern_lower in input_lower or input_lower in pattern_lower:\n                instinct[\"trigger_count\"] += 1\n                self._save_instincts()\n                return instinct\n\n        return None\n    \n    def get_statistics(self) -> Dict:\n        \"\"\"Statistiques du genome\"\"\"\n        categories = {}\n        for gene in self.genes.values():\n            if gene.category not in categories:\n                categories[gene.category] = {\"count\": 0, \"avg_success\": 0, \"total_usage\": 0}\n            categories[gene.category][\"count\"] += 1\n            categories[gene.category][\"total_usage\"] += gene.usage_count\n        \n        for cat in categories:\n            genes = self.find_genes(category=cat)\n            if genes:\n                categories[cat][\"avg_success\"] = sum(g.success_rate for g in genes) / len(genes)\n        \n        return {\n            \"total_genes\": len(self.genes),\n            \"total_mutations\": len(self.mutations),\n            \"total_instincts\": len(self.instincts),\n            \"by_category\": categories,\n            \"top_genes\": [g.key for g in self.get_best_genes(5)]\n        }\n    \n    def evolve(self) -> Dict:\n        \"\"\"\u00c9limine les g\u00e8nes faibles, garde les forts\"\"\"\n        eliminated = []\n        for key, gene in list(self.genes.items()):\n            if gene.priority < 50 and gene.success_rate < 0.3 and gene.usage_count > 10:\n                del self.genes[key]\n                eliminated.append(key)\n        \n        if eliminated:\n            logger.info(f\"Evolution: eliminated {len(eliminated)} weak genes\")\n            self._save_all()\n        \n        return {\"eliminated\": eliminated, \"surviving\": len(self.genes)}\n\n\ndef get_genome_memory() -> GenomeMemory:\n    \"\"\"Singleton genome memory\"\"\"\n    return GenomeMemory()\n\n\nif __name__ == \"__main__\":\n    print(\"=== SHARINGAN GENOME MEMORY TEST ===\\n\")\n    \n    genome = GenomeMemory()\n    \n    print(f\"Genes loaded: {len(genome.genes)}\")\n    print(f\"Mutations: {len(genome.mutations)}\")\n    print(f\"Instincts: {len(genome.instincts)}\")\n    \n    print(\"\\n1. Testing mutation:\")\n    key = genome.mutate(\"test_gene\", {\"test\": \"value\"}, \"experimental\", source=\"test\")\n    print(f\"   Created gene: {key}\")\n    \n    print(\"\\n2. Testing success recording:\")\n    genome.record_success(key)\n    gene = genome.get_gene(\"test_gene\", \"experimental\")\n    if gene:\n        print(f\"   Success rate: {gene.success_rate}\")\n    else:\n        print(\"   Gene not found\")\n    \n    print(\"\\n3. Testing instinct:\")\n    genome.add_instinct(\"hello\", \"Hello! I'm Sharingan.\", condition=\"greeting\")\n    match = genome.match_instinct(\"hello there\")\n    print(f\"   Instinct matched: {match['response'] if match else 'None'}\")\n    \n    print(\"\\n4. Statistics:\")\n    stats = genome.get_statistics()\n    print(f\"   Total genes: {stats['total_genes']}\")\n    print(f\"   By category: {stats['by_category']}\")\n    \n    print(\"\\n\u2713 Genome memory operational!\")\n",
  "checksum": "2c8baa5902674e315f4b41627a32260b8565998e874cfeff4eaf8efb8bd7300b",
  "created_at": "2026-01-14T21:35:50.160285",
  "version": "1.0"
}