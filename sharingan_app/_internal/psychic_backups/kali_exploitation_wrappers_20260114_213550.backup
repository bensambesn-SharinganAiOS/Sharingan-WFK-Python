{
  "capability_name": "kali_exploitation_wrappers",
  "content": "#!/usr/bin/env python3\n\"\"\"\nSharingan OS - Kali Exploitation Tools Wrappers\nWrappers Python pour tous les outils d'exploitation Kali Linux\n\"\"\"\n\nimport subprocess\nimport sys\nimport os\nimport json\nimport re\nfrom pathlib import Path\nfrom typing import List, Dict, Optional, Any\nfrom datetime import datetime\n\nclass MetasploitWrapper:\n    \"\"\"Wrapper Python pour Metasploit Framework\"\"\"\n\n    def __init__(self):\n        self.msfconsole = \"msfconsole\"\n        self.msfrpcd = \"msfrpcd\"\n        self.msfvenom = \"msfvenom\"\n\n    def start_console(self, **kwargs) -> Dict[str, Any]:\n        \"\"\"D\u00e9marre la console Metasploit\"\"\"\n        cmd = [self.msfconsole]\n\n        if kwargs.get(\"quiet\"):\n            cmd.append(\"-q\")\n        if kwargs.get(\"no_banner\"):\n            cmd.extend([\"-x\", \"banner off\"])\n\n        # Metasploit console est interactif, on retourne les infos de lancement\n        return {\n            \"success\": True,\n            \"command\": \" \".join(cmd),\n            \"message\": \"Metasploit console started. Use -x option for non-interactive commands.\",\n            \"interactive\": True\n        }\n\n    def search_exploit(self, query: str, **kwargs) -> Dict[str, Any]:\n        \"\"\"Recherche des exploits dans Metasploit\"\"\"\n        cmd = [self.msfconsole, \"-x\", f\"search {query}; exit\"]\n\n        result = self._run_command(cmd, kwargs.get(\"timeout\", 60))\n\n        if result[\"success\"]:\n            result[\"parsed\"] = self._parse_search_results(result[\"stdout\"])\n\n        return result\n\n    def use_exploit(self, exploit_name: str, **kwargs) -> Dict[str, Any]:\n        \"\"\"Utilise un exploit sp\u00e9cifique\"\"\"\n        commands = [\n            f\"use {exploit_name}\",\n            f\"show options\"\n        ]\n\n        if kwargs.get(\"rhost\"):\n            commands.append(f\"set RHOSTS {kwargs['rhost']}\")\n        if kwargs.get(\"rport\"):\n            commands.append(f\"set RPORT {kwargs['rport']}\")\n        if kwargs.get(\"lhost\"):\n            commands.append(f\"set LHOST {kwargs['lhost']}\")\n        if kwargs.get(\"lport\"):\n            commands.append(f\"set LPORT {kwargs['lport']}\")\n\n        commands.append(\"exit\")\n\n        cmd = [self.msfconsole, \"-x\", \"; \".join(commands)]\n\n        return self._run_command(cmd, kwargs.get(\"timeout\", 120))\n\n    def create_payload(self, payload: str, format: str = \"exe\", **kwargs) -> Dict[str, Any]:\n        \"\"\"Cr\u00e9e un payload avec msfvenom\"\"\"\n        cmd = [self.msfvenom, \"-p\", payload, \"-f\", format]\n\n        if kwargs.get(\"output_file\"):\n            cmd.extend([\"-o\", kwargs[\"output_file\"]])\n        if kwargs.get(\"lhost\"):\n            cmd.extend([\"LHOST=\" + kwargs[\"lhost\"]])\n        if kwargs.get(\"lport\"):\n            cmd.extend([\"LPORT=\" + str(kwargs[\"lport\"])])\n        if kwargs.get(\"encoder\"):\n            cmd.extend([\"-e\", kwargs[\"encoder\"]])\n        if kwargs.get(\"iterations\"):\n            cmd.extend([\"-i\", str(kwargs[\"iterations\"])])\n\n        result = self._run_command(cmd, kwargs.get(\"timeout\", 300))\n\n        if result[\"success\"] and not kwargs.get(\"output_file\"):\n            result[\"payload_data\"] = result[\"stdout\"]\n\n        return result\n\n    def _parse_search_results(self, output: str) -> List[Dict[str, Any]]:\n        \"\"\"Parse les r\u00e9sultats de recherche Metasploit\"\"\"\n        results = []\n\n        lines = output.split('\\n')\n        in_results = False\n\n        for line in lines:\n            line = line.strip()\n\n            # D\u00e9tecter le d\u00e9but des r\u00e9sultats\n            if \"Name\" in line and \"Disclosure Date\" in line:\n                in_results = True\n                continue\n\n            if in_results and line and not line.startswith(\"-----\"):\n                # Ligne de r\u00e9sultat\n                parts = line.split()\n                if len(parts) >= 4:\n                    result = {\n                        \"name\": parts[0],\n                        \"rank\": \" \".join(parts[1:-2]) if len(parts) > 4 else parts[1],\n                        \"disclosure_date\": parts[-2],\n                        \"type\": parts[-1]\n                    }\n                    results.append(result)\n\n        return results\n\n    def _run_command(self, cmd: List[str], timeout: int = 300) -> Dict[str, Any]:\n        \"\"\"Ex\u00e9cute une commande\"\"\"\n        try:\n            result = subprocess.run(\n                cmd,\n                capture_output=True,\n                text=True,\n                timeout=timeout\n            )\n\n            return {\n                \"success\": result.returncode == 0,\n                \"returncode\": result.returncode,\n                \"stdout\": result.stdout,\n                \"stderr\": result.stderr,\n                \"command\": \" \".join(cmd)\n            }\n        except subprocess.TimeoutExpired:\n            return {\n                \"success\": False,\n                \"error\": f\"Command timed out after {timeout}s\",\n                \"timeout\": True\n            }\n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n\nclass SqlmapWrapper:\n    \"\"\"Wrapper Python pour SQLMap\"\"\"\n\n    def __init__(self):\n        self.command = \"sqlmap\"\n\n    def scan_url(self, url: str, **kwargs) -> Dict[str, Any]:\n        \"\"\"Scanne une URL pour les vuln\u00e9rabilit\u00e9s SQL injection\"\"\"\n        cmd = [self.command, \"-u\", url]\n\n        # Options de scan\n        if kwargs.get(\"database\"):\n            cmd.append(\"--dbs\")\n        if kwargs.get(\"tables\"):\n            cmd.extend([\"-D\", kwargs[\"tables\"], \"--tables\"])\n        if kwargs.get(\"columns\"):\n            cmd.extend([\"-D\", kwargs[\"columns\"], \"-T\", kwargs.get(\"table\", \"\"), \"--columns\"])\n        if kwargs.get(\"dump\"):\n            cmd.extend([\"-D\", kwargs[\"dump\"], \"-T\", kwargs.get(\"table\", \"\"), \"--dump\"])\n        if kwargs.get(\"batch\"):\n            cmd.append(\"--batch\")\n        if kwargs.get(\"risk\"):\n            cmd.extend([\"--risk\", str(kwargs[\"risk\"])])\n        if kwargs.get(\"level\"):\n            cmd.extend([\"--level\", str(kwargs[\"level\"])])\n        if kwargs.get(\"output_file\"):\n            cmd.extend([\"-o\", kwargs[\"output_file\"]])\n\n        result = self._run_command(cmd, kwargs.get(\"timeout\", 600))\n\n        if result[\"success\"]:\n            result[\"parsed\"] = self._parse_sqlmap_output(result[\"stdout\"])\n\n        return result\n\n    def scan_request_file(self, request_file: str, **kwargs) -> Dict[str, Any]:\n        \"\"\"Scanne un fichier de requ\u00eate\"\"\"\n        cmd = [self.command, \"-r\", request_file]\n\n        # M\u00eame options que scan_url\n        if kwargs.get(\"database\"):\n            cmd.append(\"--dbs\")\n        if kwargs.get(\"tables\"):\n            cmd.extend([\"-D\", kwargs[\"tables\"], \"--tables\"])\n        if kwargs.get(\"batch\"):\n            cmd.append(\"--batch\")\n\n        result = self._run_command(cmd, kwargs.get(\"timeout\", 600))\n\n        if result[\"success\"]:\n            result[\"parsed\"] = self._parse_sqlmap_output(result[\"stdout\"])\n\n        return result\n\n    def _parse_sqlmap_output(self, output: str) -> Dict[str, Any]:\n        \"\"\"Parse la sortie SQLMap\"\"\"\n        parsed = {\n            \"vulnerable\": False,\n            \"injection_types\": [],\n            \"databases\": [],\n            \"tables\": [],\n            \"columns\": [],\n            \"dumped_data\": []\n        }\n\n        lines = output.split('\\n')\n\n        for line in lines:\n            line = line.strip()\n\n            if \"is vulnerable\" in line or \"vulnerable to\" in line:\n                parsed[\"vulnerable\"] = True\n\n            if \"Parameter:\" in line and (\"vulnerable\" in line or \"injectable\" in line):\n                match = re.search(r'Parameter: ([^(]+)', line)\n                if match:\n                    parsed[\"injection_types\"].append(match.group(1).strip())\n\n            if line.startswith(\"[\") and \"]\" in line and \"available databases\" in line:\n                # Liste des bases de donn\u00e9es\n                db_match = re.search(r'\\[([^]]+)\\]', line)\n                if db_match:\n                    parsed[\"databases\"] = db_match.group(1).split(\", \")\n\n            if line.startswith(\"[\") and \"]\" in line and \"tables\" in line:\n                # Liste des tables\n                table_match = re.search(r'\\[([^]]+)\\]', line)\n                if table_match:\n                    parsed[\"tables\"] = table_match.group(1).split(\", \")\n\n        return parsed\n\n    def _run_command(self, cmd: List[str], timeout: int = 600) -> Dict[str, Any]:\n        \"\"\"Ex\u00e9cute une commande\"\"\"\n        try:\n            result = subprocess.run(\n                cmd,\n                capture_output=True,\n                text=True,\n                timeout=timeout\n            )\n\n            return {\n                \"success\": result.returncode == 0,\n                \"returncode\": result.returncode,\n                \"stdout\": result.stdout,\n                \"stderr\": result.stderr,\n                \"command\": \" \".join(cmd)\n            }\n        except subprocess.TimeoutExpired:\n            return {\n                \"success\": False,\n                \"error\": f\"Command timed out after {timeout}s\",\n                \"timeout\": True\n            }\n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n\nclass SearchsploitWrapper:\n    \"\"\"Wrapper Python pour Searchsploit\"\"\"\n\n    def __init__(self):\n        self.command = \"searchsploit\"\n\n    def search(self, query: str, **kwargs) -> Dict[str, Any]:\n        \"\"\"Recherche des exploits\"\"\"\n        cmd = [self.command, query]\n\n        if kwargs.get(\"json\"):\n            cmd.append(\"--json\")\n        if kwargs.get(\"exact\"):\n            cmd.append(\"--exact\")\n        if kwargs.get(\"case\"):\n            cmd.append(\"--case\")\n        if kwargs.get(\"colour\"):\n            cmd.append(\"--colour\")\n\n        result = self._run_command(cmd, kwargs.get(\"timeout\", 30))\n\n        if result[\"success\"]:\n            if kwargs.get(\"json\"):\n                result[\"parsed\"] = json.loads(result[\"stdout\"])\n            else:\n                result[\"parsed\"] = self._parse_searchsploit_output(result[\"stdout\"])\n\n        return result\n\n    def view_exploit(self, exploit_id: str, **kwargs) -> Dict[str, Any]:\n        \"\"\"Affiche le contenu d'un exploit\"\"\"\n        cmd = [self.command, \"-x\", exploit_id]\n\n        result = self._run_command(cmd, kwargs.get(\"timeout\", 30))\n\n        if result[\"success\"]:\n            result[\"exploit_content\"] = result[\"stdout\"]\n\n        return result\n\n    def download_exploit(self, exploit_id: str, output_dir: str = \".\", **kwargs) -> Dict[str, Any]:\n        \"\"\"T\u00e9l\u00e9charge un exploit\"\"\"\n        cmd = [self.command, \"-m\", exploit_id, \"-o\", output_dir]\n\n        result = self._run_command(cmd, kwargs.get(\"timeout\", 60))\n\n        return result\n\n    def _parse_searchsploit_output(self, output: str) -> List[Dict[str, Any]]:\n        \"\"\"Parse la sortie Searchsploit\"\"\"\n        results = []\n\n        lines = output.split('\\n')\n        in_results = False\n\n        for line in lines:\n            line = line.strip()\n\n            # Ignorer les lignes d'en-t\u00eate\n            if \"Description\" in line and \"Path\" in line:\n                in_results = True\n                continue\n\n            if in_results and line and not line.startswith(\"---\") and \"|\" in line:\n                parts = line.split(\"|\")\n                if len(parts) >= 3:\n                    result = {\n                        \"path\": parts[0].strip(),\n                        \"description\": parts[1].strip(),\n                        \"type\": parts[2].strip() if len(parts) > 2 else \"\"\n                    }\n                    results.append(result)\n\n        return results\n\n    def _run_command(self, cmd: List[str], timeout: int = 30) -> Dict[str, Any]:\n        \"\"\"Ex\u00e9cute une commande\"\"\"\n        try:\n            result = subprocess.run(\n                cmd,\n                capture_output=True,\n                text=True,\n                timeout=timeout\n            )\n\n            return {\n                \"success\": result.returncode == 0,\n                \"returncode\": result.returncode,\n                \"stdout\": result.stdout,\n                \"stderr\": result.stderr,\n                \"command\": \" \".join(cmd)\n            }\n        except subprocess.TimeoutExpired:\n            return {\n                \"success\": False,\n                \"error\": f\"Command timed out after {timeout}s\",\n                \"timeout\": True\n            }\n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n\n# Gestionnaire unifi\u00e9 pour les outils d'exploitation\nclass ExploitationToolsManager:\n    \"\"\"Gestionnaire unifi\u00e9 des outils d'exploitation\"\"\"\n\n    def __init__(self):\n        self.tools = {\n            \"metasploit\": MetasploitWrapper(),\n            \"sqlmap\": SqlmapWrapper(),\n            \"searchsploit\": SearchsploitWrapper()\n        }\n\n    def get_tool(self, name: str):\n        \"\"\"R\u00e9cup\u00e8re un outil par nom\"\"\"\n        return self.tools.get(name)\n\n    def list_tools(self) -> List[str]:\n        \"\"\"Liste tous les outils disponibles\"\"\"\n        return list(self.tools.keys())\n\n    def search_exploits(self, query: str, tool: str = \"searchsploit\", **kwargs) -> Dict[str, Any]:\n        \"\"\"Recherche des exploits\"\"\"\n        if tool == \"metasploit\":\n            return self.tools[\"metasploit\"].search_exploit(query, **kwargs)\n        elif tool == \"searchsploit\":\n            return self.tools[\"searchsploit\"].search(query, **kwargs)\n        else:\n            return {\"error\": f\"Unsupported exploit search tool: {tool}\"}\n\n    def scan_sql_injection(self, target: str, **kwargs) -> Dict[str, Any]:\n        \"\"\"Scanne pour les injections SQL\"\"\"\n        return self.tools[\"sqlmap\"].scan_url(target, **kwargs)\n\n    def create_metasploit_payload(self, payload: str, **kwargs) -> Dict[str, Any]:\n        \"\"\"Cr\u00e9e un payload Metasploit\"\"\"\n        return self.tools[\"metasploit\"].create_payload(payload, **kwargs)\n\ndef get_exploitation_tools_manager():\n    \"\"\"Get exploitation tools manager instance\"\"\"\n    return ExploitationToolsManager()\n\ndef main():\n    \"\"\"Test des wrappers d'exploitation\"\"\"\n    import argparse\n\n    parser = argparse.ArgumentParser(description=\"Exploitation Tools Wrappers\")\n    parser.add_argument(\"--tool\", choices=[\"metasploit\", \"sqlmap\", \"searchsploit\"],\n                       default=\"searchsploit\", help=\"Tool to use\")\n    parser.add_argument(\"--action\", choices=[\"search\", \"scan\", \"create\"], default=\"search\",\n                       help=\"Action to perform\")\n    parser.add_argument(\"target\", help=\"Target (URL, query, etc.)\")\n    parser.add_argument(\"--output\", \"-o\", help=\"Output file\")\n    parser.add_argument(\"--json\", action=\"store_true\", help=\"JSON output\")\n\n    args = parser.parse_args()\n\n    manager = ExploitationToolsManager()\n\n    print(f\"\ud83d\udca5 Running {args.tool} {args.action}...\")\n\n    result = {\"error\": \"Unsupported action/tool combination\"}\n\n    if args.action == \"search\":\n        result = manager.search_exploits(args.target, args.tool, output_file=args.output)\n    elif args.action == \"scan\" and args.tool == \"sqlmap\":\n        result = manager.scan_sql_injection(args.target, output_file=args.output)\n    elif args.action == \"create\" and args.tool == \"metasploit\":\n        result = manager.create_metasploit_payload(args.target, output_file=args.output)\n\n    if args.json:\n        print(json.dumps(result, indent=2, default=str))\n    else:\n        if result.get(\"success\"):\n            print(\"\u2705 Exploitation operation completed successfully\")\n            if \"parsed\" in result:\n                parsed = result[\"parsed\"]\n                if isinstance(parsed, list) and parsed:\n                    print(f\"Found {len(parsed)} results\")\n                    for item in parsed[:3]:  # Montrer les 3 premiers\n                        if \"description\" in item:\n                            print(f\"  - {item['description']}\")\n                        elif \"name\" in item:\n                            print(f\"  - {item['name']}\")\n                elif isinstance(parsed, dict):\n                    if \"vulnerable\" in parsed:\n                        print(f\"Vulnerable: {parsed['vulnerable']}\")\n                    if \"databases\" in parsed and parsed[\"databases\"]:\n                        print(f\"Databases found: {len(parsed['databases'])}\")\n        else:\n            print(f\"\u274c Exploitation operation failed: {result.get('error', 'Unknown error')}\")\n\nif __name__ == \"__main__\":\n    main()\n",
  "checksum": "0f62381b165fe1080954620ebe80baf4d6c74b9d5d93373442dd3da70c1d1c80",
  "created_at": "2026-01-14T21:35:50.216812",
  "version": "1.0"
}