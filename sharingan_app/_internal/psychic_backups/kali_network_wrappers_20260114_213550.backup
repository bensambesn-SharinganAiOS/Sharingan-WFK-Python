{
  "capability_name": "kali_network_wrappers",
  "content": "#!/usr/bin/env python3\n\"\"\"\nSharingan OS - Network Tools Wrappers\nWrappers Python pour tous les outils r\u00e9seau Kali Linux\n\"\"\"\n\nimport subprocess\nimport sys\nimport os\nimport json\nfrom pathlib import Path\nfrom typing import List, Dict, Optional, Any\nfrom datetime import datetime\nimport threading\nimport time\n\nclass NmapWrapper:\n    \"\"\"Wrapper Python pour Nmap\"\"\"\n\n    def __init__(self):\n        self.command = \"nmap\"\n        self.name = \"nmap\"\n        self.description = \"Network Mapper - Advanced port scanner\"\n\n    def scan(self, target: str, options: str = \"-sV -p-\", **kwargs) -> Dict[str, Any]:\n        \"\"\"Effectue un scan Nmap\"\"\"\n        cmd = [self.command, options, target]\n\n        # Options suppl\u00e9mentaires\n        if kwargs.get(\"aggressive\"):\n            cmd.insert(1, \"-A\")\n        if kwargs.get(\"os_detection\"):\n            cmd.insert(1, \"-O\")\n        if kwargs.get(\"script_scan\"):\n            cmd.insert(1, \"--script=vuln\")\n        if kwargs.get(\"timing\"):\n            cmd.insert(1, f\"-T{kwargs['timing']}\")\n        if kwargs.get(\"output_file\"):\n            cmd.extend([\"-oN\", kwargs[\"output_file\"]])\n\n        result = self._run_command(cmd, kwargs.get(\"timeout\", 300))\n\n        # Parser les r\u00e9sultats\n        if result[\"success\"]:\n            result[\"parsed\"] = self._parse_nmap_output(result[\"stdout\"])\n\n        return result\n\n    def _parse_nmap_output(self, output: str) -> Dict[str, Any]:\n        \"\"\"Parse la sortie Nmap\"\"\"\n        parsed = {\n            \"hosts\": [],\n            \"ports\": [],\n            \"services\": [],\n            \"os_detection\": None\n        }\n\n        lines = output.split('\\n')\n        current_host = None\n\n        for line in lines:\n            line = line.strip()\n            if \"Nmap scan report for\" in line:\n                if current_host:\n                    parsed[\"hosts\"].append(current_host)\n                current_host = {\"address\": line.split()[-1], \"ports\": [], \"services\": []}\n            elif \"/tcp\" in line or \"/udp\" in line:\n                if current_host:\n                    port_info = self._parse_port_line(line)\n                    if port_info:\n                        current_host[\"ports\"].append(port_info)\n                        parsed[\"ports\"].append(port_info)\n            elif \"Service detection performed\" in line:\n                continue\n            elif \"OS details:\" in line:\n                parsed[\"os_detection\"] = line.replace(\"OS details:\", \"\").strip()\n\n        if current_host:\n            parsed[\"hosts\"].append(current_host)\n\n        return parsed\n\n    def _parse_port_line(self, line: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Parse une ligne de port Nmap\"\"\"\n        try:\n            parts = line.split()\n            if len(parts) >= 3:\n                port_protocol = parts[0].split('/')\n                state = parts[1]\n                service = parts[2]\n\n                return {\n                    \"port\": int(port_protocol[0]),\n                    \"protocol\": port_protocol[1],\n                    \"state\": state,\n                    \"service\": service,\n                    \"version\": \" \".join(parts[3:]) if len(parts) > 3 else \"\"\n                }\n        except:\n            pass\n        return None\n\n    def _run_command(self, cmd: List[str], timeout: int = 300) -> Dict[str, Any]:\n        \"\"\"Ex\u00e9cute une commande\"\"\"\n        try:\n            result = subprocess.run(\n                cmd,\n                capture_output=True,\n                text=True,\n                timeout=timeout\n            )\n\n            return {\n                \"success\": result.returncode == 0,\n                \"returncode\": result.returncode,\n                \"stdout\": result.stdout,\n                \"stderr\": result.stderr,\n                \"command\": \" \".join(cmd),\n                \"execution_time\": 0.0  # Would need to measure\n            }\n        except subprocess.TimeoutExpired:\n            return {\n                \"success\": False,\n                \"error\": f\"Command timed out after {timeout}s\",\n                \"timeout\": True\n            }\n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n\nclass MasscanWrapper:\n    \"\"\"Wrapper Python pour Masscan\"\"\"\n\n    def __init__(self):\n        self.command = \"masscan\"\n        self.name = \"masscan\"\n        self.description = \"Mass IP port scanner\"\n\n    def scan(self, target: str, ports: str = \"1-65535\", rate: int = 1000, **kwargs) -> Dict[str, Any]:\n        \"\"\"Effectue un scan Masscan\"\"\"\n        cmd = [\n            self.command,\n            target,\n            \"-p\", ports,\n            \"--rate\", str(rate)\n        ]\n\n        # Options suppl\u00e9mentaires\n        if kwargs.get(\"output_file\"):\n            cmd.extend([\"-oL\", kwargs[\"output_file\"]])\n        if kwargs.get(\"exclude_file\"):\n            cmd.extend([\"--excludefile\", kwargs[\"exclude_file\"]])\n        if kwargs.get(\"source_ip\"):\n            cmd.extend([\"--source-ip\", kwargs[\"source_ip\"]])\n\n        result = self._run_command(cmd, kwargs.get(\"timeout\", 600))\n\n        if result[\"success\"]:\n            result[\"parsed\"] = self._parse_masscan_output(result[\"stdout\"])\n\n        return result\n\n    def _parse_masscan_output(self, output: str) -> List[Dict[str, Any]]:\n        \"\"\"Parse la sortie Masscan\"\"\"\n        results = []\n\n        for line in output.split('\\n'):\n            line = line.strip()\n            if line and not line.startswith('#') and '\\t' in line:\n                parts = line.split('\\t')\n                if len(parts) >= 3:\n                    results.append({\n                        \"timestamp\": parts[0],\n                        \"ip\": parts[1],\n                        \"port\": int(parts[2]),\n                        \"protocol\": parts[3] if len(parts) > 3 else \"tcp\"\n                    })\n\n        return results\n\n    def _run_command(self, cmd: List[str], timeout: int = 600) -> Dict[str, Any]:\n        \"\"\"Ex\u00e9cute une commande\"\"\"\n        try:\n            result = subprocess.run(\n                cmd,\n                capture_output=True,\n                text=True,\n                timeout=timeout\n            )\n\n            return {\n                \"success\": result.returncode == 0,\n                \"returncode\": result.returncode,\n                \"stdout\": result.stdout,\n                \"stderr\": result.stderr,\n                \"command\": \" \".join(cmd)\n            }\n        except subprocess.TimeoutExpired:\n            return {\n                \"success\": False,\n                \"error\": f\"Command timed out after {timeout}s\",\n                \"timeout\": True\n            }\n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n\nclass NetdiscoverWrapper:\n    \"\"\"Wrapper Python pour Netdiscover\"\"\"\n\n    def __init__(self):\n        self.command = \"netdiscover\"\n        self.name = \"netdiscover\"\n        self.description = \"Network address discovery\"\n\n    def discover(self, range_ip: str = \"192.168.1.0/24\", **kwargs) -> Dict[str, Any]:\n        \"\"\"Effectue une d\u00e9couverte r\u00e9seau\"\"\"\n        cmd = [self.command, \"-r\", range_ip, \"-P\", \"-s\", \"1\"]\n\n        # Options suppl\u00e9mentaires\n        if kwargs.get(\"interface\"):\n            cmd.extend([\"-i\", kwargs[\"interface\"]])\n        if kwargs.get(\"passive\"):\n            cmd.remove(\"-s\")\n            cmd.remove(\"1\")\n        if kwargs.get(\"timeout\"):\n            cmd.extend([\"-t\", str(kwargs[\"timeout\"])])\n        if kwargs.get(\"output_file\"):\n            cmd.extend([\">\", kwargs[\"output_file\"]])\n\n        result = self._run_command(cmd, kwargs.get(\"timeout\", 60))\n\n        if result[\"success\"]:\n            result[\"parsed\"] = self._parse_netdiscover_output(result[\"stdout\"])\n\n        return result\n\n    def _parse_netdiscover_output(self, output: str) -> List[Dict[str, Any]]:\n        \"\"\"Parse la sortie Netdiscover\"\"\"\n        hosts = []\n\n        for line in output.split('\\n'):\n            if '.' in line and ':' in line and not line.startswith(' '):\n                parts = line.split()\n                if len(parts) >= 2:\n                    ip_mac = parts[0].split('/')\n                    hosts.append({\n                        \"ip\": ip_mac[0],\n                        \"mac\": ip_mac[1] if len(ip_mac) > 1 else parts[1],\n                        \"vendor\": \" \".join(parts[2:]) if len(parts) > 2 else \"\"\n                    })\n\n        return hosts\n\n    def _run_command(self, cmd: List[str], timeout: int = 60) -> Dict[str, Any]:\n        \"\"\"Ex\u00e9cute une commande\"\"\"\n        try:\n            result = subprocess.run(\n                cmd,\n                capture_output=True,\n                text=True,\n                timeout=timeout\n            )\n\n            return {\n                \"success\": result.returncode == 0,\n                \"returncode\": result.returncode,\n                \"stdout\": result.stdout,\n                \"stderr\": result.stderr,\n                \"command\": \" \".join(cmd)\n            }\n        except subprocess.TimeoutExpired:\n            return {\n                \"success\": False,\n                \"error\": f\"Command timed out after {timeout}s\",\n                \"timeout\": True\n            }\n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n\nclass ArpScanWrapper:\n    \"\"\"Wrapper Python pour Arp-scan\"\"\"\n\n    def __init__(self):\n        self.command = \"arp-scan\"\n        self.name = \"arp-scan\"\n        self.description = \"ARP network scanner\"\n\n    def scan(self, interface: str = \"eth0\", target: Optional[str] = None, **kwargs) -> Dict[str, Any]:\n        \"\"\"Effectue un scan ARP\"\"\"\n        cmd = [self.command, \"--interface\", interface]\n\n        if target:\n            cmd.append(target)\n        else:\n            cmd.append(\"--localnet\")\n\n        # Options suppl\u00e9mentaires\n        if kwargs.get(\"verbose\"):\n            cmd.append(\"--verbose\")\n        if kwargs.get(\"output_file\"):\n            cmd.extend([\"-o\", kwargs[\"output_file\"]])\n        if kwargs.get(\"vendor\"):\n            cmd.append(\"--vendor\")\n\n        result = self._run_command(cmd, kwargs.get(\"timeout\", 30))\n\n        if result[\"success\"]:\n            result[\"parsed\"] = self._parse_arpscan_output(result[\"stdout\"])\n\n        return result\n\n    def _parse_arpscan_output(self, output: str) -> List[Dict[str, Any]]:\n        \"\"\"Parse la sortie Arp-scan\"\"\"\n        hosts = []\n\n        for line in output.split('\\n'):\n            line = line.strip()\n            if '\\t' in line and not line.startswith('Interface') and not line.startswith('Starting'):\n                parts = line.split('\\t')\n                if len(parts) >= 3:\n                    hosts.append({\n                        \"ip\": parts[0],\n                        \"mac\": parts[1],\n                        \"vendor\": parts[2] if len(parts) > 2 else \"\"\n                    })\n\n        return hosts\n\n    def _run_command(self, cmd: List[str], timeout: int = 30) -> Dict[str, Any]:\n        \"\"\"Ex\u00e9cute une commande\"\"\"\n        try:\n            result = subprocess.run(\n                cmd,\n                capture_output=True,\n                text=True,\n                timeout=timeout\n            )\n\n            return {\n                \"success\": result.returncode == 0,\n                \"returncode\": result.returncode,\n                \"stdout\": result.stdout,\n                \"stderr\": result.stderr,\n                \"command\": \" \".join(cmd)\n            }\n        except subprocess.TimeoutExpired:\n            return {\n                \"success\": False,\n                \"error\": f\"Command timed out after {timeout}s\",\n                \"timeout\": True\n            }\n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n\nclass Hping3Wrapper:\n    \"\"\"Wrapper Python pour Hping3\"\"\"\n\n    def __init__(self):\n        self.command = \"hping3\"\n        self.name = \"hping3\"\n        self.description = \"TCP/IP packet assembler/analyzer\"\n\n    def scan(self, target: str, scan_type: str = \"syn\", ports: str = \"1-100\", **kwargs) -> Dict[str, Any]:\n        \"\"\"Effectue un scan avec Hping3\"\"\"\n        cmd = [self.command, target]\n\n        # Type de scan\n        if scan_type == \"syn\":\n            cmd.extend([\"--scan\", ports])\n        elif scan_type == \"ack\":\n            cmd.extend([\"-A\", \"-p\", ports])\n        elif scan_type == \"fin\":\n            cmd.extend([\"-F\", \"-p\", ports])\n        elif scan_type == \"xmas\":\n            cmd.extend([\"-X\", \"-p\", ports])\n\n        # Options suppl\u00e9mentaires\n        if kwargs.get(\"flood\"):\n            cmd.append(\"--flood\")\n        if kwargs.get(\"verbose\"):\n            cmd.append(\"-v\")\n        if kwargs.get(\"count\"):\n            cmd.extend([\"-c\", str(kwargs[\"count\"])])\n        if kwargs.get(\"interface\"):\n            cmd.extend([\"-I\", kwargs[\"interface\"]])\n\n        result = self._run_command(cmd, kwargs.get(\"timeout\", 60))\n\n        if result[\"success\"]:\n            result[\"parsed\"] = self._parse_hping3_output(result[\"stdout\"])\n\n        return result\n\n    def flood(self, target: str, **kwargs) -> Dict[str, Any]:\n        \"\"\"Effectue un flood avec Hping3\"\"\"\n        cmd = [self.command, target, \"--flood\"]\n\n        if kwargs.get(\"syn\"):\n            cmd.append(\"--syn\")\n        if kwargs.get(\"ack\"):\n            cmd.append(\"--ack\")\n        if kwargs.get(\"rst\"):\n            cmd.append(\"--rst\")\n\n        return self._run_command(cmd, kwargs.get(\"timeout\", 30))\n\n    def _parse_hping3_output(self, output: str) -> Dict[str, Any]:\n        \"\"\"Parse la sortie Hping3\"\"\"\n        parsed = {\n            \"packets\": [],\n            \"statistics\": {}\n        }\n\n        lines = output.split('\\n')\n        for line in lines:\n            line = line.strip()\n            if \"len=\" in line and \"ip=\" in line:\n                # Ligne de paquet\n                parsed[\"packets\"].append(line)\n            elif \"packets transmitted\" in line:\n                # Statistiques\n                parts = line.split(',')\n                for part in parts:\n                    if \"packets transmitted\" in part:\n                        parsed[\"statistics\"][\"transmitted\"] = part.split()[0]\n                    elif \"packets received\" in part:\n                        parsed[\"statistics\"][\"received\"] = part.split()[0]\n                    elif \"packet loss\" in part:\n                        parsed[\"statistics\"][\"loss\"] = part.split()[0]\n\n        return parsed\n\n    def _run_command(self, cmd: List[str], timeout: int = 60) -> Dict[str, Any]:\n        \"\"\"Ex\u00e9cute une commande\"\"\"\n        try:\n            result = subprocess.run(\n                cmd,\n                capture_output=True,\n                text=True,\n                timeout=timeout\n            )\n\n            return {\n                \"success\": result.returncode == 0,\n                \"returncode\": result.returncode,\n                \"stdout\": result.stdout,\n                \"stderr\": result.stderr,\n                \"command\": \" \".join(cmd)\n            }\n        except subprocess.TimeoutExpired:\n            return {\n                \"success\": False,\n                \"error\": f\"Command timed out after {timeout}s\",\n                \"timeout\": True\n            }\n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n\n# Gestionnaire unifi\u00e9 pour les outils r\u00e9seau\nclass NetworkToolsManager:\n    \"\"\"Gestionnaire unifi\u00e9 des outils r\u00e9seau\"\"\"\n\n    def __init__(self):\n        self.tools = {\n            \"nmap\": NmapWrapper(),\n            \"masscan\": MasscanWrapper(),\n            \"netdiscover\": NetdiscoverWrapper(),\n            \"arp-scan\": ArpScanWrapper(),\n            \"hping3\": Hping3Wrapper()\n        }\n\n    def get_tool(self, name: str):\n        \"\"\"R\u00e9cup\u00e8re un outil par nom\"\"\"\n        return self.tools.get(name)\n\n    def list_tools(self) -> List[str]:\n        \"\"\"Liste tous les outils disponibles\"\"\"\n        return list(self.tools.keys())\n\n    def scan_network(self, target: str, method: str = \"nmap\", **kwargs) -> Dict[str, Any]:\n        \"\"\"Effectue un scan r\u00e9seau avec l'outil sp\u00e9cifi\u00e9\"\"\"\n        tool = self.get_tool(method)\n        if not tool:\n            return {\"error\": f\"Unknown scanning method: {method}\"}\n\n        if method == \"nmap\":\n            return tool.scan(target, **kwargs)\n        elif method == \"masscan\":\n            return tool.scan(target, **kwargs)\n        elif method == \"netdiscover\":\n            return tool.discover(target, **kwargs)\n        elif method == \"arp-scan\":\n            return tool.scan(target=target, **kwargs)\n        elif method == \"hping3\":\n            return tool.scan(target, **kwargs)\n        else:\n            return {\"error\": f\"Unsupported scan method: {method}\"}\n\ndef main():\n    \"\"\"Test des wrappers r\u00e9seau\"\"\"\n    import argparse\n\n    parser = argparse.ArgumentParser(description=\"Network Tools Wrappers\")\n    parser.add_argument(\"target\", help=\"Target to scan\")\n    parser.add_argument(\"--tool\", choices=[\"nmap\", \"masscan\", \"netdiscover\", \"arp-scan\", \"hping3\"],\n                       default=\"nmap\", help=\"Tool to use\")\n    parser.add_argument(\"--output\", \"-o\", help=\"Output file\")\n    parser.add_argument(\"--json\", action=\"store_true\", help=\"JSON output\")\n\n    args = parser.parse_args()\n\n    manager = NetworkToolsManager()\n\n    print(f\"\ud83d\udd0d Scanning {args.target} with {args.tool}...\")\n\n    result = manager.scan_network(args.target, args.tool, output_file=args.output)\n\n    if args.json:\n        print(json.dumps(result, indent=2, default=str))\n    else:\n        if result.get(\"success\"):\n            print(\"\u2705 Scan completed successfully\")\n            if \"parsed\" in result:\n                parsed = result[\"parsed\"]\n                if \"hosts\" in parsed:\n                    print(f\"Found {len(parsed['hosts'])} hosts\")\n                elif \"ports\" in parsed:\n                    print(f\"Found {len(parsed['ports'])} open ports\")\n                else:\n                    print(f\"Results: {len(parsed) if isinstance(parsed, list) else 'N/A'} items\")\n        else:\n            print(f\"\u274c Scan failed: {result.get('error', 'Unknown error')}\")\n\nif __name__ == \"__main__\":\n    main()",
  "checksum": "709ea14a6cdeea8a619eae17721d5176d3bf9f58eed0c09f73cd6334c755fd40",
  "created_at": "2026-01-14T21:35:50.205750",
  "version": "1.0"
}